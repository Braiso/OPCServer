<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="24.11.1.0">
<procedure name="main">
<interface/>
<body>
<c>***************************** -- 1.VARIABLE INIT -- *****************************</c>
<l>optimize_aop ('', '', '', 'none', 'none')</l>
<c></c>
<l>Operator := 'threshold'</l>
<l>IconicType := 'image'</l>
<l>IconicTypeStep := 'iconic_type:input(0)'</l>
<l>ParStep := ['parameter:threshold']</l>
<l>ParValue := [128, 200, 255]</l>
<c></c>
<l>query_detailed_aop_information (Operator, IconicTypeStep, IconicType, ParStep, ParValue, Message)</l>
<c></c>
<c></c>
<c>***** ### Configuracion de ventana grafica ### *****</c>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>dev_open_window (-120, 0, 512,512, 'black', WindowHandle1)</l>
<l>dev_open_window (-120, 1375, 512,512, 'black', WindowHandle2)</l>
<c></c>
<c>***** ### Variables compartidas ### *****</c>
<l>global tuple SharedDataBack</l>
<l>SharedDataBack := [0, 0, 0, 0, 0, 0]</l>
<c></c>
<c>* Meidicion de tiempo de ciclo total</c>
<l>count_seconds (StartTime) </l>
<c></c>
<c>***** ### VARIABLES GLOBALES ### *****</c>
<l>offline := 1</l>
<l>Init_Variables_Globales (Version, Celda, offline, reset_comunicacion, Umbral_Esp_Medio,\
                         Tol_Esq_Rotas, xTolerance, yTolerance, Area_Min_Error, Margen_Esp,\
                         Save_Image, ciclos_debug, debug_dir)</l>
<c></c>
<c>****************************** -- 2.GENERAL LOOP -- *****************************</c>
<l>while(true)</l>
<c>    </c>
<c>    ************************* -- 3.GENERAL VARIABLE INIT -- *************************    </c>
<l>    Init_Variables_Generales (Codigo_Error, Vision_Realizada, Largo_Medido, Ancho_Medido,\
                              Espesor_Medido, Tercio_Visible, Calidad_Tercio_1, Calidad_Tercio_3,\
                              Fichero_Cargado_1, Fichero_Cargado_2, ID_Pizarra_Out, ciclo, max_ciclo)</l>
<c>   </c>
<c>    ************************ -- 4.IMPORTACION DE VARIABLES -- *********************** </c>
<c>    </c>
<c>    ***** ### VARIABLES DE CELDA ### *****</c>
<l>    if (Codigo_Error == 0)</l>
<c>        </c>
<c>        * datos_vision.txt</c>
<l>        Variables_Celda (Celda, IP, DB_PLC, Ruta_Imagenes, Ruta_Config, Ruta_Offline, Ruta_HMI, Codigo_Error)</l>
<l>    endif    </l>
<c>   </c>
<c>    **************************** -- 5.CONEXION CON PLC -- ***************************   </c>
<l>    if (Codigo_Error == 0)</l>
<l>        Conexion_PLC (WindowHandle1, IP, Celda, reset_comunicacion, Version, offline, ciclo, IoDeviceHandle, Codigo_Error)</l>
<l>    endif</l>
<c>    </c>
<c>    ****************** -- 6.LECTURA CANALES DE COMUNICACION PLC -- ******************    </c>
<l>    if (Codigo_Error == 0)                </l>
<l>        Lectura_Canales_PLC (IoDeviceHandle, DB_PLC, offline, Io_Realizar_Vision, Io_Espesor_Nominal, Io_Cargar_Fichero_1,\
        Io_Cargar_Fichero_2, Io_Control_Esquinas_1, Io_Control_Esquinas_2, Io_Control_Perforaciones_1, Io_Control_Perforaciones_2,\
        Io_Produccion, Io_ID_Pizarra_In, Io_Codigo_Error, Io_Vision_Realizada, Io_Largo_Medido, Io_Ancho_Medido, Io_Espesor_Medido,\
        Io_Tercio_Visible, Io_Calidad_Tercio_1, Io_Calidad_Tercio_3, Io_Fichero_Cargado_1, Io_Fichero_Cargado_2, Io_ID_Pizarra_Out,\
        Io_ID_Produccion_1, Io_ID_Produccion_2, Io_LiveBit_In, Io_LiveBit_Out, Codigo_Error)</l>
<c>        </c>
<c>        ***** ### Tarea en segundo plano ### *****</c>
<l>        par_start&lt;Background&gt; : Background (Io_LiveBit_In, Io_LiveBit_Out, offline)</l>
<c>        </c>
<l>    endif</l>
<c>    </c>
<c>    ****************** -- 7.CARGAR INICIAL FICHEROS PRODUCCION -- *******************    </c>
<c>    * Se activa parametro offline para omitir secuencia PLC</c>
<c>    </c>
<c>    ***** ### VARIABLES APILADOR 1 ### *****</c>
<l>    if (Codigo_Error == 0)</l>
<l>        Variables_Produccion (Io_Cargar_Fichero_1, Io_Fichero_Cargado_1, Io_ID_Produccion_1,\
                          './Produccion_1.csv', 'true', Dict_Var_Prod_1, ID_Produccion_1, Codigo_Error)</l>
<l>    endif</l>
<c>    </c>
<c>    ***** ### VARIABLES APILADOR 2 ### *****</c>
<l>    if (Codigo_Error == 0)</l>
<l>        Variables_Produccion (Io_Cargar_Fichero_2, Io_Fichero_Cargado_2, Io_ID_Produccion_2,\
                          './Produccion_2.csv', 'true', Dict_Var_Prod_2, ID_Produccion_2, Codigo_Error)    </l>
<l>    endif</l>
<c>    </c>
<c>    ********************** -- 8.INICIALIZACION DE LA CAMARA -- **********************         </c>
<l>    if (Codigo_Error == 0)</l>
<l>        Conexion_Camara (Ruta_Config, offline, WindowHandle1, Celda, Version, ciclo, AcqHandle, Codigo_Error)</l>
<l>    endif</l>
<c>              </c>
<c>    ******************************* -- 9.CYCLE LOOP  ******************************    </c>
<l>    if (Codigo_Error==0)</l>
<l>        while (true)</l>
<c>        </c>
<c>            ************************** -- 10.CYCLE VARIABLE INIT -- **************************            </c>
<l>            Codigo_Error := 0</l>
<c>        </c>
<c>            ************************* -- 11.ADQUISICIÓN DE IMAGEN -- *************************                        </c>
<l>            if (offline == 0)                                </l>
<c>                </c>
<c>                * Captura imagen asincrona</c>
<l>                while (true)</l>
<l>                    try        </l>
<l>                        grab_image_async (Image, AcqHandle, 99.9)  </l>
<c>                        </c>
<c>                        * Guardar imagen para depuracion</c>
<l>                        if (Save_Image) </l>
<l>                            write_image (Image, 'hobj', 0, Ruta_Offline +'Image' + ciclo )                    </l>
<l>                        endif                        </l>
<l>                        break</l>
<l>                    catch (Exception)                        </l>
<l>                        try</l>
<c>                            * Io_Cargar_Fichero_1</c>
<l>                            read_io_channel (Io_Cargar_Fichero_1, Cargar_Fichero_1, Status)</l>
<c>                            </c>
<c>                            * Io_Cargar_Fichero_2</c>
<l>                            read_io_channel (Io_Cargar_Fichero_2, Cargar_Fichero_2, Status)                            </l>
<l>                        catch (Exception)                            </l>
<c>                            * Error lectura canales OPC UA</c>
<l>                            Codigo_Error := 9998</l>
<l>                        endtry                       </l>
<c>                        </c>
<l>                        if (Cargar_Fichero_1=='true' or Cargar_Fichero_2=='true')</l>
<l>                            break</l>
<l>                        endif</l>
<l>                    endtry</l>
<l>                endwhile                                                                             </l>
<l>            else            </l>
<c></c>
<c>                * Recorre las imagenes de un directorio</c>
<l>                if (debug_dir)      </l>
<c>                    </c>
<c>                    * Ruta de imagenes de depuracion</c>
<l>                    path:= './IMAGENES/OFFLINE'</l>
<l>                    list_files(path, 'files', ImageFiles) </l>
<l>                    cantidad_imagenes:=|ImageFiles|</l>
<c>                    </c>
<l>                    if (ciclos_debug&gt;=cantidad_imagenes)</l>
<l>                        ciclos_debug:=0</l>
<l>                    endif</l>
<c>                    </c>
<c>                    * Cargar imagen desde disco</c>
<l>                    read_image (Image, ImageFiles[ciclos_debug])</l>
<c>                    </c>
<l>                    ciclos_debug:=ciclos_debug+1                        </l>
<l>                else</l>
<c>                    </c>
<c>                    * Cargar imagen desde disco</c>
<l>                    read_image (Image,Ruta_Offline + 'Image0.hobj')                </l>
<l>                endif                                     </l>
<l>            endif                    </l>
<c>                                                                     </c>
<c>            *************************** -- 12.LEER ENTRADAS PLC -- **************************         </c>
<l>            if (offline!=1)</l>
<c>                </c>
<c>                * Lectura de señales PLC </c>
<l>                Read_Inputs_PLC (Io_Espesor_Nominal, Io_Control_Esquinas_1, Io_Control_Esquinas_2,\
                                 Io_Control_Perforaciones_1, Io_Control_Perforaciones_2, Io_Produccion,\
                                 Io_ID_Pizarra_In, Io_Cargar_Fichero_1, Io_Cargar_Fichero_2, Espesor_Nominal,\
                                 Control_Esquinas_1, Control_Esquinas_2, Control_Perforaciones_1,\
                                 Control_Perforaciones_2, Produccion, ID_Pizarra_In, Cargar_Fichero_1,\
                                 Cargar_Fichero_2, Codigo_Error)</l>
<l>            else</l>
<c>            </c>
<c>                * Modificar segun las imagenes offline</c>
<l>                Espesor_Nominal:=5     </l>
<l>                Control_Esquinas_1:=0</l>
<l>                Control_Esquinas_2:=0</l>
<l>                Control_Perforaciones_1:=0</l>
<l>                Control_Perforaciones_2:=0</l>
<l>                Produccion:=1</l>
<l>                ID_Pizarra_In:=ciclos_debug</l>
<c>                </c>
<c>                * Para pruebas offline</c>
<l>                Cargar_Fichero_1:=0</l>
<l>                Cargar_Fichero_2:=0</l>
<l>            endif</l>
<c>            </c>
<c>            * Indicar a PLC a que pizarra pertenece el ciclo</c>
<l>            ID_Pizarra_Out:=ID_Pizarra_In</l>
<c>            </c>
<c>            ******************** -- 13.IMPORTAR VARIABLES PRODUCCION -- *********************                  </c>
<l>            if (Codigo_Error == 0 and (Cargar_Fichero_1=='true' or Cargar_Fichero_2=='true'))</l>
<c>                </c>
<c>                ***** ### VARIABLES APILADOR 1 ### *****</c>
<l>                if (Cargar_Fichero_1=='true')</l>
<l>                    Variables_Produccion (Io_Cargar_Fichero_1, Io_Fichero_Cargado_1, Io_ID_Produccion_1,\
                                      './Produccion_1.csv', offline, Dict_Var_Prod_1, ID_Produccion_1, Codigo_Error)</l>
<l>                endif                      </l>
<c>                </c>
<c>                ***** ### VARIABLES APILADOR 2 ### *****</c>
<l>                if (Cargar_Fichero_2=='true')</l>
<l>                    Variables_Produccion (Io_Cargar_Fichero_2, Io_Fichero_Cargado_2, Io_ID_Produccion_2,\
                                      './Produccion_2.csv', offline, Dict_Var_Prod_2, ID_Produccion_2, Codigo_Error)</l>
<l>                endif                               </l>
<l>            endif       </l>
<c>            </c>
<c>            ************************ -- 14.VOLCAR DATOS PRODUCION -- ************************    </c>
<l>            if (Codigo_Error==0)</l>
<l>                switch (Produccion)</l>
<l>                case 1:</l>
<c>                    </c>
<c>                    * Produccion procedente de apilador 1</c>
<l>                    Dict_Var_Prod:=Dict_Var_Prod_1</l>
<l>                    Control_Esquinas:=Control_Esquinas_1</l>
<l>                    Control_Perforaciones:=Control_Perforaciones_1</l>
<l>                    break</l>
<l>                case 2:</l>
<c>                    </c>
<c>                    * Produccion procedente de apilador 2</c>
<l>                    Dict_Var_Prod:=Dict_Var_Prod_2</l>
<l>                    Control_Esquinas:=Control_Esquinas_2</l>
<l>                    Control_Perforaciones:=Control_Perforaciones_2                    </l>
<l>                    break</l>
<c>                    </c>
<l>                default:</l>
<l>                    throw (['Numero de produccion fuera de rango'])                            </l>
<l>                endswitch                                </l>
<l>            endif            </l>
<c>            </c>
<c>            ********************** -- 15.EXTRACCION CARACTERISTICAS -- **********************           </c>
<l>            if (Codigo_Error == 0)                    </l>
<c>                ** Extrae datos relevantes de una imagen adquirida a través de GenTL **</c>
<l>                Go2GenTL_ParseData (Image, HeightMap, Intensity, 0, FrameCount, Timestamp, EncoderPosition, EncoderIndex,\
                                    Inputs, xOffset, xResolution, yOffset, yResolution, zOffset, zResolution, Width,\
                                    Length, HasIntensity, NumScans)</l>
<c>                </c>
<c>                * Este procedimiento convierte un mapa de alturas en coordenadas métricas (X, Y, Z).</c>
<c>                * Se basa en la resolución y el desplazamiento definidos en los parámetros de entrada. </c>
<l>                Imagenes_XYZ_heightmap (Image, HeightMap, X, Y, Z, xResolution, xOffset, yResolution, yOffset, zResolution, zOffset)</l>
<l>            endif</l>
<c>            </c>
<c>            * Pruebas con master - ANULADAS</c>
<l>            if (Codigo_Error == 0 and 0)</l>
<l>                xyz_to_object_model_3d (X, Y, Z, ObjectModel3D)                                        </l>
<l>            endif</l>
<c>            </c>
<c>            ****************************** -- 16.PREPOCESADO -- *****************************                </c>
<c>            ** Filtrado **</c>
<c>            ** Correcion  de iluminacion **</c>
<c>            ** Correccion de formato **</c>
<c>            ** Correcion geometrica **</c>
<c>            ** Suavizado de imagenes **     </c>
<c>            </c>
<c>            ***************************** -- 17.SEGMENTACION -- *****************************              </c>
<l>            if (Codigo_Error == 0)                                                                                                                                               </l>
<l>                Segmentacion (Z, Image, Region, OriginalRegion, ZRed, GrayImageScaled, Codigo_Error)</l>
<c>            </c>
<l>                if (Codigo_Error == 0)   </l>
<l>                    threshold(Image, Mask, 0, 0)                </l>
<l>                    connection (Mask, ConnectedRegions)</l>
<l>                    region_features (ConnectedRegions, 'area', AreaValues)                </l>
<l>                    tuple_max (AreaValues, Max)</l>
<l>                    tuple_find (AreaValues, Max, Indices)</l>
<l>                    remove_obj (ConnectedRegions, ConnectedRegionsRM, Indices)  </l>
<l>                endif                </l>
<l>            endif</l>
<c>            </c>
<c>            ****************************** -- 18.TRATAMIENTO -- *****************************            </c>
<c>            *                     /\
            *                    /  \
            *                   /_  _\
            *                     || </c>
<c>            *                     || Sentido de avance</c>
<c>            *</c>
<c>            *    Esquina 1  ______________  Esquina 2</c>
<c>            *              |    Borde     |</c>
<c>            *              |  Superior(1) |</c>
<c>            *              |              |</c>
<c>            * Borde        |              | Borde </c>
<c>            * Izquierda(2) |              | Derecha (3)</c>
<c>            *              |              |</c>
<c>            *              |   Borde      |</c>
<c>            *              |  Inferior(4) |</c>
<c>            *              |______________|</c>
<c>            *    Esquina 3                  Esquina 4</c>
<c>            </c>
<c>            </c>
<c>            ***** ### NORMALIZAR GEOMETRIA PIZARRA ### *****            </c>
<l>            if (Codigo_Error==0)</l>
<l>                Normalizar (Region, ZRed, Rectangle_Norm, Region_Sup, Region_Inter, Region_Inf, \
                            Region_Izq, Region_Der, Bordes_Norm, Corner_Rows, Corner_Cols, Codigo_Error)</l>
<l>            endif</l>
<c>               </c>
<c>            ************************ -- 19.DEFECTOS ESTRUCTURALES -- ************************                                    </c>
<c>            </c>
<c>            ***** ### CONTROL EXCEPCION ESQUINAS CORTADAS 10x10 ### *****</c>
<l>            if (Codigo_Error==0)</l>
<l>                Control_Area (ZRed, Rectangle_Norm, OriginalRegion, Bordes_Norm, AreaFaults, CornerFaults,\
                              Rectangle_Norm_Esq, Corner_Rows, Corner_Cols, xTolerance/xResolution, yTolerance/yResolution,\
                              Tol_Esq_Rotas, Area_Min_Error, Esquinas_Rotas, Codigo_Error)</l>
<l>            else</l>
<c>                </c>
<c>                * Fallos 'variable no inicialiada' en visualizaciones</c>
<l>                gen_empty_obj (AreaFaults)</l>
<l>                gen_empty_obj (CornerFaults)</l>
<l>                gen_empty_obj (Rectangle_Norm_Esq)</l>
<l>                Esquinas_Rotas:=[-1,-1,-1,-1]</l>
<l>            endif</l>
<c></c>
<c>            ***** ### CONTROL ESQUINAS CORTADAS ### *****</c>
<l>            if (Codigo_Error==0 and Control_Esquinas=='true')</l>
<l>            else                                </l>
<c>                * Error 'variable no inicialiada' en visualizaciones            </c>
<l>            endif                        </l>
<c>            </c>
<c>            </c>
<c>            ***** ### CONTROL PERFORACIONES ### *****</c>
<l>            if (Codigo_Error==0 and Control_Perforaciones=='false')</l>
<l>            else                                </l>
<c>                * Error 'variable no inicialiada' en visualizaciones            </c>
<l>            endif                        </l>
<c>            </c>
<c>            ************************* -- 20.ANALISIS DIMENSIONAL -- *************************</c>
<c>            </c>
<c>            ***** ### MEDICIONES PLANO XY ### *****            </c>
<l>            if (Codigo_Error==0)</l>
<l>                Medicion_XY (Rectangle_Norm, ZRed, X, Y, Bordes_Norm, Corner_Rows, Corner_Cols,\
                             WindowHandle1, Dimensiones, Area_Norm, Angle_Corner_Deg, Angle_Corner_Rad,\
                             Centro_Pizarra_X, Centro_Pizarra_Y, Centro_Pizarra_RZ, Pixel_Size,\
                             Largo_Medio, Ancho_Medio, Codigo_Error)</l>
<l>            else                </l>
<c>                * Error 'variable no inicialiada' en visualizaciones            </c>
<l>                Dimensiones:=[-1,-1,-1,-1]</l>
<l>                Area_Norm:=-1</l>
<l>                Angle_Corner_Deg:=-1</l>
<l>                Angle_Corner_Rad:=-1</l>
<l>                Centro_Pizarra_X:=999999</l>
<l>                Centro_Pizarra_Y:=999999</l>
<l>                Centro_Pizarra_RZ:=999999</l>
<l>                Pixel_Size:=-1</l>
<l>                Largo_Medio:=-1</l>
<l>                Ancho_Medio:=-1</l>
<l>            endif</l>
<c>                </c>
<c>            ** Descontar los bordes en la region e imagen para el control de espesor**</c>
<l>            if (Codigo_Error==0)</l>
<l>                Variables_Planeidad (Rectangle_Norm, ZRed, X, Y, RegionPlan, ImagePlan, Margen_Esp, Pixel_Size, Codigo_Error)        </l>
<l>            else                </l>
<c>                * Error 'variable no inicialiada' en visualizaciones            </c>
<l>            endif</l>
<c>            </c>
<c>            ***** ### MEDICIONES PLANO Z ### *****</c>
<l>            if (Codigo_Error==0)</l>
<l>                Medicion_Z (RegionPlan, ImagePlan, Espesor_Minimo, Espesor_Maximo, Espesor_Medio, Codigo_Error)     </l>
<l>            else                </l>
<c>                * Error 'variable no inicialiada' en visualizaciones            </c>
<l>                Espesor_Minimo:=-1</l>
<l>                Espesor_Medio:=-1</l>
<l>                Espesor_Maximo:=-1           </l>
<l>                Per_Esp_Medio:=-1</l>
<l>            endif</l>
<c>                      </c>
<c>            ***** ### DESVIACION DE LONGITUD ### *****            </c>
<l>            if (Codigo_Error==0)</l>
<l>                Control_Largo (Dimensiones, Dict_Var_Prod, Codigo_Error)</l>
<l>            else                </l>
<c>                * Error 'variable no inicialiada' en visualizaciones            </c>
<l>            endif</l>
<c>            </c>
<c>            ***** ### DESVIACION ANCHURAS ### *****           </c>
<l>            if (Codigo_Error==0)</l>
<l>                Control_Ancho (Dimensiones, Dict_Var_Prod, Codigo_Error)        </l>
<l>            else                </l>
<c>                * Error 'variable no inicialiada' en visualizaciones                          </c>
<l>            endif</l>
<c>                                                                                     </c>
<c>            ***** ### DESVIACION DE ESPESOR ### *****</c>
<l>            if (Codigo_Error==0)</l>
<l>                Control_Espesor (RegionPlan, ImagePlan, Region_Esp_OK, Region_Esp_Inf, Region_Esp_Sup, Dict_Var_Prod, Espesor_Nominal,\
                                 Espesor_Minimo, Espesor_Maximo, Espesor_Medio, Umbral_Esp_Medio, Per_Esp_Medio, Valores_MinMax, \
                                 Calidad_Espesor, Codigo_Error)                </l>
<c>                </c>
<c>                * [0]: Calidad Espesor</c>
<l>                Calidades[0]:=Calidad_Espesor</l>
<l>            else</l>
<c>                * Error 'variable no inicialiada' en visualizaciones            </c>
<c>                </c>
<l>                gen_empty_obj (Region_Esp_Inf)</l>
<l>                gen_empty_obj (Region_Esp_OK)</l>
<l>                gen_empty_obj (Region_Esp_Sup)</l>
<l>                Per_Esp_Medio:=-1</l>
<l>                Valores_MinMax:=[-1,-1,-1,-1]</l>
<l>                Calidad_Espesor:=-1</l>
<l>                Calidades[0]:=-1</l>
<l>            endif    </l>
<c>                           </c>
<c>            ***** ### DESVIACION DE LINEALIDAD DE ARISTAS ### *****</c>
<c>            </c>
<c>            ***** ### DESVIACION DE ORTOGONALIDAD ### *****</c>
<c>               </c>
<c>            ***** ### DESVIACION DE PLANEIDAD ### *****</c>
<c>            </c>
<c>            ***** ### DESVIACION DE CONCAVIDAD ### *****</c>
<c>                        </c>
<c>            *************** -- 21.DEFINICION DE CALIDAD Y TERCIOS VISIBLES -- ***************</c>
<c>            </c>
<c>            ***** ### CALIDAD ### *****            </c>
<c>            </c>
<c>            * Sin codigo de error o codigo relacionado solo con calidad</c>
<l>            if (Codigo_Error==0)</l>
<l>                Calidad (Calidades, Calidad, Codigo_Error)</l>
<c>                </c>
<c>                * Las CALIDADES de los tercios se corresponde con la calidad general (espesor)               </c>
<c>                * Calidad 1 y 2</c>
<c></c>
<l>                Calidad_Tercio_1:=Calidad                </l>
<l>                Calidad_Tercio_3:=Calidad                </l>
<l>            else</l>
<c>                </c>
<c>                * Si hay algun codigo de error se descarta directamente</c>
<c>                * En la visualizacion si se filtra segun error</c>
<c>                </c>
<c>                * Los DESCARTES puede estan causados por:</c>
<c>                * 1. Espesor fuera de limites</c>
<c>                * 2. Defectos estructurales</c>
<c>                * 3. Controles dimensionales negativos                </c>
<c>                </c>
<l>                Calidad:=-1</l>
<l>                Calidad_Tercio_1:=Calidad</l>
<l>                Calidad_Tercio_3:=Calidad</l>
<l>            endif       </l>
<c>                    </c>
<c>            ***** ### TERCIOS VISIBLES ### *****            </c>
<l>            if (Codigo_Error==0)</l>
<c>                </c>
<c>                * Sin codigo de error la clasificacion de los tercios se determina por los defectos estructurales:</c>
<c>                * 1. Esquinas cortadas</c>
<c>                * 2. Perforaciones</c>
<l>                Tercios_Visibles (Esquinas_Rotas, Tercio_Visible, Codigo_Error)</l>
<l>            else                </l>
<c>                * Con codigo de error la pizarra es un descarte     </c>
<l>                Tercio_Visible:=-1</l>
<l>            endif                </l>
<c>            </c>
<c>            ************************* -- 22.ESCRIBIR SALIDAS PLC -- *************************</c>
<l>            if (offline!=1)</l>
<l>                 try</l>
<c>                    ** Escribir salidas **</c>
<l>                    Write_Outputs_PLC (Io_Codigo_Error, Io_Largo_Medido, Io_Ancho_Medido, Io_Espesor_Medido,\
                                       Io_Tercio_Visible, Io_Calidad_Tercio_1, Io_Calidad_Tercio_3, Io_ID_Pizarra_Out,\
                                       Largo_Medio, Codigo_Error, Ancho_Medio, Espesor_Medio, Tercio_Visible,\
                                       Calidad_Tercio_1, Calidad_Tercio_3, ID_Pizarra_Out)</l>
<c>                </c>
<c>                    ** Secuencia "Realizar Vision - Vision Realizada" **</c>
<l>                    Secuencia_VR_RV (Io_Realizar_Vision, Io_Vision_Realizada)</l>
<c>                    </c>
<l>                 catch (Exception)</l>
<l>                    dev_display_exception (WindowHandle1, Exception)         </l>
<c>                    </c>
<c>                    * Error lectura canales OPC UA</c>
<l>                    Codigo_Error:=9998 </l>
<l>                endtry     </l>
<l>            endif</l>
<c>            </c>
<c>            ***************************** -- 23.VISUALIZACION -- ****************************</c>
<c>                                                                                 </c>
<l>            try</l>
<c>                * Borrar pantallas</c>
<l>                dev_set_window (WindowHandle1)</l>
<l>                dev_clear_window ()</l>
<l>                dev_set_window (WindowHandle2)</l>
<l>                dev_clear_window ()               </l>
<c>                </c>
<c>                * Datos generales</c>
<l>                Visualizacion_Celda (WindowHandle1, Celda, Version)</l>
<l>                Visualizacion_Celda (WindowHandle2, Celda, Version)</l>
<c>                       </c>
<c>                * Visualizaciones segun rango de error</c>
<l>                if (Codigo_Error==0 or (Codigo_Error&gt;=100 and Codigo_Error&lt;200))                                                           </l>
<c>                    ***** ### VISUALIZACION CONTROL DIMENSIONAL ### *****</c>
<c>                    </c>
<c>                    ** Pantalla 1 **</c>
<l>                    Visu_Main (ZRed, OriginalRegion, Region_Sup, Region_Inter, Region_Inf, Region_Esp_Inf,\
                               Region_Esp_Sup, AreaFaults, WindowHandle1, Calidad_Tercio_1, Calidad_Tercio_3, Tercio_Visible)                       </l>
<c>                    </c>
<c>                    ** Pantalla 2 **</c>
<l>                    Visu_Main_2 (Rectangle_Norm, Rectangle_Norm_Esq, Bordes_Norm, WindowHandle1, WindowHandle2, Codigo_Error,\
                                 ID_Pizarra_Out, Dict_Var_Prod, Espesor_Nominal, Largo_Medio, Ancho_Medio, Espesor_Medio, Per_Esp_Medio,\
                                 Espesor_Minimo, Esquinas_Rotas, Corner_Rows, Corner_Cols, xTolerance, xResolution, yTolerance,\
                                 yResolution, Dimensiones, Umbral_Esp_Medio, Largo_Nominal, Ancho_Nominal, Phi, Index, Per_Esp_Medio,\
                                 Espesor_Minimo)</l>
<c>                    </c>
<l>                elseif (Codigo_Error&gt;=200 and Codigo_Error&lt;300)</l>
<c>    </c>
<c>                    ***** ### VISUALIZACION ERRORES FUNCIONAMIENTO SISTEMA ### *****               </c>
<l>                    Visu_Error_Funcionamiento (Image, WindowHandle1, Codigo_Error)</l>
<c>                    </c>
<l>                elseif (Codigo_Error&gt;=9000 and Codigo_Error&lt;1000000)</l>
<c>                    </c>
<c>                    ***** ### VISUALIZACION ERRORES ESTADO SISTEMA ### *****                     </c>
<l>                    Visu_Error_Sistema (WindowHandle1, Codigo_Error)</l>
<l>                endif                </l>
<c>                </c>
<l>            catch (Exception)</l>
<c>                </c>
<l>            endtry</l>
<c>                                                     </c>
<c>            ******************************* -- 24.FIN CICLO -- ******************************</c>
<c>        </c>
<c>            ***** ### ESTADISITICAS ### *****</c>
<c>            * Incremento de ciclo</c>
<l>            if (ciclo&lt;max_ciclo)              </l>
<l>                ciclo:=ciclo+1</l>
<l>            else</l>
<l>                ciclo:=0</l>
<l>            endif                                </l>
<c>            </c>
<c>            * Finalizar la medición</c>
<l>            count_seconds (EndTime)</l>
<c>            </c>
<c>            * Calcular duracion</c>
<l>            Duration:= EndTime - StartTime            </l>
<c>            </c>
<c>            * Degbug: mostrar tiempo de ciclo</c>
<l>            if (1)</l>
<l>                dev_set_window (WindowHandle1)</l>
<l>                set_display_font (WindowHandle1, 12, 'mono', 'true', 'false')</l>
<l>                tuple_string (Duration, '.3f', String)</l>
<l>                dev_disp_text ('Tiempo proc.: ' + String + 's', 'window', 'top', 150, 'black', [], [])                                                                       </l>
<l>            endif</l>
<c>                        </c>
<l>            if (ciclos_debug&gt;=cantidad_imagenes)</l>
<l>                 dev_disp_text ('fin', 'window', 'center', 'center', 'black', [], [])  </l>
<l>                 stop()</l>
<c>                </c>
<c>                 * Meidicion de tiempo de ciclo total</c>
<l>                count_seconds (StartTime)                 </l>
<l>            endif                        </l>
<c>            </c>
<c>            * Para pruebas offline se para en cada ciclo</c>
<l>            if (offline=1)</l>
<l>*                 stop()        </l>
<l>            else            </l>
<c>                ***** ### REGISTRO DE CAPTURAS DE PANTALLA ### *****            </c>
<c>                </c>
<c>                * Para mostrar en el HMI</c>
<l>                dump_window_image (I1, WindowHandle1)</l>
<l>                dump_window_image (I2, WindowHandle2)</l>
<c>                </c>
<l>                concat_obj (I2, I1, ObjectsConcat)</l>
<l>                tile_images (ObjectsConcat, TiledImage, 2, 'horizontal')                </l>
<l>                Save_HMI_Images (TiledImage, Ruta_HMI)                    </l>
<l>            endif                                                                        </l>
<l>        endwhile            </l>
<l>    endif       </l>
<l>endwhile    </l>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="Medicion_XY">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="X" base_type="iconic" dimension="0"/>
<par name="Y" base_type="iconic" dimension="0"/>
<par name="Bordes_Norm" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Corner_Rows" base_type="ctrl" dimension="0"/>
<par name="Corner_Cols" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Dimensiones" base_type="ctrl" dimension="0"/>
<par name="Area_Norm" base_type="ctrl" dimension="0"/>
<par name="Angle_Corner_Deg" base_type="ctrl" dimension="0"/>
<par name="Angle_Corner_Rad" base_type="ctrl" dimension="0"/>
<par name="Centro_Pizarra_X" base_type="ctrl" dimension="0"/>
<par name="Centro_Pizarra_Y" base_type="ctrl" dimension="0"/>
<par name="Centro_Pizarra_RZ" base_type="ctrl" dimension="0"/>
<par name="Pixel_Size" base_type="ctrl" dimension="0"/>
<par name="Largo_Medio" base_type="ctrl" dimension="0"/>
<par name="Ancho_Medio" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Extrae las caracteristicas dimensionales de una pieza en el plano XY</c>
<c>* a partir de una region normalizada. Calcula los lados, el area, los</c>
<c>* angulos en las esquinas y la orientacion general.</c>
<c>*</c>
<c>* ENTRADAS (icono):</c>
<c>* -Region           : region normalizada de la pieza</c>
<c>* -Image            : imagen principal (visualizacion)</c>
<c>* -X                : imagen de escala en X (mm/pixel)</c>
<c>* -Y                : imagen de escala en Y (mm/pixel)</c>
<c>* -Bordes_Norm      : contornos de bordes normalizados</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* -Corner_Rows      : coordenadas fila de las esquinas (4 valores)</c>
<c>* -Corner_Cols      : coordenadas columna de las esquinas (4 valores)</c>
<c>* -WindowHandle     : handle de la ventana de visualizacion</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* -Dimensiones       : tupla con longitud de los 4 lados (mm)</c>
<c>* -Area_Norm         : area en mm² de la region normalizada</c>
<c>* -Angle_Corner_Deg  : angulos en grados en cada esquina</c>
<c>* -AngleRad          : angulos en radianes en cada esquina</c>
<c>* -Centro_Pizarra_X  : coordenada X del centro (en mm)</c>
<c>* -Centro_Pizarra_Y  : coordenada Y del centro (en mm)</c>
<c>* -Centro_Pizarra_RZ : orientacion general (en grados)</c>
<c>* -Pixel_Size        : resolucion en X, Y y area pixel</c>
<c>* -Largo_Medio       : media de lados verticales (mm)</c>
<c>* -Ancho_Medio       : media de lados horizontales (mm)</c>
<c>* -Codigo_Error      : reserva</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<l>if (false)</l>
<l>    dev_clear_window ()</l>
<l>    dev_display (Image)</l>
<l>    dev_display (Region) </l>
<l>    dev_display (Image)</l>
<l>endif</l>
<c></c>
<c>** Medir dimensiones</c>
<c></c>
<c>* Orientacion de region normalizada</c>
<l>smallest_rectangle2 (Region, Row, Column, Rad, Length1, Length2)</l>
<l>tuple_deg2 (Rad, Deg)</l>
<l>Centro_Pizarra_RZ := Deg+90</l>
<c></c>
<c>* Calcular las longitudes de los bordes en mm</c>
<l>distancia_mm (X, Y, Image, Bordes_Norm, Corner_Rows[0], Corner_Cols[0], Corner_Rows[1], Corner_Cols[1], dist_superior, dist_px_superior)</l>
<l>distancia_mm (X, Y, Image, Bordes_Norm, Corner_Rows[0], Corner_Cols[0], Corner_Rows[2], Corner_Cols[2], dist_izquierda, dist_px_izquierda)</l>
<l>distancia_mm (X, Y, Image, Bordes_Norm, Corner_Rows[1], Corner_Cols[1], Corner_Rows[3], Corner_Cols[3], dist_derecha, dist_px_derecha)</l>
<l>distancia_mm (X, Y, Image, Bordes_Norm, Corner_Rows[2], Corner_Cols[2], Corner_Rows[3], Corner_Cols[3], dist_inferior, dist_px_inferior)</l>
<l>Dimensiones := [dist_superior,dist_izquierda, dist_derecha,dist_inferior]</l>
<c></c>
<c>* Calculo de longitud y anchura media</c>
<l>largos:=[dist_izquierda,dist_derecha]</l>
<l>anchos:=[dist_superior,dist_inferior]</l>
<l>tuple_median (largos, Largo_Medio)</l>
<l>tuple_median (anchos, Ancho_Medio)</l>
<c></c>
<c>* Area y centro</c>
<l>pixel_size (X, Y, px_x_size, px_y_size, px_area)</l>
<l>Pixel_Size:=[px_x_size,px_y_size,px_area]</l>
<l>area_center (Region, Area_Norm, Row1, Column1)</l>
<l>Area_Norm := Area_Norm * px_area</l>
<c></c>
<c>* Calcular coordenadas del centro en mm</c>
<l>get_grayval (X, Row1, Column1, Centro_Pizarra_X)</l>
<l>get_grayval (Y, Row1, Column1, Centro_Pizarra_Y)</l>
<c></c>
<c>* Calcular angulos en las esquinas (en grados)</c>
<c></c>
<c>* Vertices poligono </c>
<l>v1:=[Corner_Rows[0], Corner_Cols[0]]</l>
<l>v2:=[Corner_Rows[1], Corner_Cols[1]]</l>
<l>v3:=[Corner_Rows[2], Corner_Cols[2]]</l>
<l>v4:=[Corner_Rows[3], Corner_Cols[3]]</l>
<c>  </c>
<l>if (false)</l>
<c>    * Identificacion de vertices</c>
<l>    dev_disp_text ('v1', 'image', v1[0], v1[1], 'black', [], [])</l>
<l>    dev_disp_text ('v2', 'image', v2[0], v2[1], 'black', [], [])</l>
<l>    dev_disp_text ('v3', 'image', v3[0], v3[1], 'black', [], [])</l>
<l>    dev_disp_text ('v4', 'image', v4[0], v4[1], 'black', [], [])</l>
<c>    </c>
<c>    * Codigo viejo</c>
<c>    </c>
<c>    * superior(e1/e2)-izquierda(e1/e3)</c>
<l>    angle_ll (Corner_Rows[0], Corner_Cols[0], Corner_Rows[1], Corner_Cols[1], Corner_Rows[0], Corner_Cols[0], Corner_Rows[2], Corner_Cols[2], AngleRad_e1)</l>
<c>    </c>
<c>    * superior(e1/e2)-derecha(e2/e4)</c>
<l>    angle_ll (Corner_Rows[0], Corner_Cols[0], Corner_Rows[1], Corner_Cols[1], Corner_Rows[1], Corner_Cols[1], Corner_Rows[3], Corner_Cols[3], AngleRad_e2)</l>
<c>    </c>
<c>    * inferior(e3/e4)-izquierda(e1/e3)</c>
<l>    angle_ll (Corner_Rows[2], Corner_Cols[2], Corner_Rows[3], Corner_Cols[3], Corner_Rows[0], Corner_Cols[0], Corner_Rows[2], Corner_Cols[2], AngleRad_e3)</l>
<c>    </c>
<c>    * inferior(e3/e4)-derecha(e2/e4)</c>
<l>    angle_ll (Corner_Rows[2], Corner_Cols[2], Corner_Rows[3], Corner_Cols[3], Corner_Rows[1], Corner_Cols[1], Corner_Rows[3], Corner_Cols[3], AngleRad_e4)</l>
<c></c>
<l>endif</l>
<c></c>
<c>* Angulo 1: v3-&gt;v1 / v2-&gt;v1</c>
<l>angle_ll (v3[0], v3[1], v1[0], v1[1],v2[0], v2[1], v1[0], v1[1],  AngleRad_e1)</l>
<l>deg1:=deg(AngleRad_e1)</l>
<c></c>
<c>* Angulo 2: v1-&gt;v2 / v4-&gt;v2</c>
<l>angle_ll (v1[0], v1[1], v2[0], v2[1], v4[0], v4[1], v2[0], v2[1], AngleRad_e2)</l>
<l>deg2:=deg(AngleRad_e2)</l>
<c></c>
<c>* Angulo 3: v4-&gt;v3 / v1-&gt;v3</c>
<l>angle_ll ( v4[0], v4[1], v3[0], v3[1],v1[0], v1[1], v3[0], v3[1], AngleRad_e3)</l>
<l>deg3:=deg(AngleRad_e3)</l>
<c></c>
<c>* Angulo 4: v2-&gt;v4 / v3-&gt;v4</c>
<l>angle_ll ( v2[0], v2[1], v4[0], v4[1],v3[0], v3[1], v4[0], v4[1], AngleRad_e4)</l>
<l>deg4:=deg(AngleRad_e4)</l>
<c></c>
<c>* Agrupar los angulos</c>
<l>Angle_Corner_Rad := [AngleRad_e1,AngleRad_e2,AngleRad_e3,AngleRad_e4]</l>
<l>tuple_deg (Angle_Corner_Rad, Angle_Corner_Deg)</l>
<c></c>
<c>* Comprobacion de coherencia (suma de angulos debe ser 360)</c>
<l>tuple_sum (Angle_Corner_Deg, Sum)</l>
<l>tuple_round (Sum, Sum)</l>
<c></c>
<l>if (Sum!=360)</l>
<l>    dev_disp_text ('Suma de angulos incoherente', 'window', 'center', 'center', 'black', [], [])</l>
<l>    throw ('SUMA DE ANGULOS INCOHERENTE (&lt;&gt;4): ' + Sum + 'GRADOS')</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Medicion_XY">
<parameters>
<parameter id="Ancho_Medio"/>
<parameter id="Angle_Corner_Deg"/>
<parameter id="Angle_Corner_Rad"/>
<parameter id="Area_Norm"/>
<parameter id="Bordes_Norm"/>
<parameter id="Centro_Pizarra_RZ"/>
<parameter id="Centro_Pizarra_X"/>
<parameter id="Centro_Pizarra_Y"/>
<parameter id="Codigo_Error"/>
<parameter id="Corner_Cols"/>
<parameter id="Corner_Rows"/>
<parameter id="Dimensiones"/>
<parameter id="Image"/>
<parameter id="Largo_Medio"/>
<parameter id="Pixel_Size"/>
<parameter id="Region"/>
<parameter id="WindowHandle"/>
<parameter id="X"/>
<parameter id="Y"/>
</parameters>
</docu>
</procedure>
<procedure name="caras">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Region_Sup" base_type="iconic" dimension="0"/>
<par name="Region_Inter" base_type="iconic" dimension="0"/>
<par name="Region_Inf" base_type="iconic" dimension="0"/>
<par name="Region_Izq" base_type="iconic" dimension="0"/>
<par name="Region_Der" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Devuelve las subregiones de una region principal (superior, intermedia, inferior,</c>
<c>* izquierda y derecha) ajustadas a la orientacion original de la pieza. Para ello,</c>
<c>* realiza una rotacion para alinear los ejes, divide la region en particiones y</c>
<c>* vuelve a rotarlas a su posicion original.</c>
<c></c>
<c>* ENTRADAS (icono):</c>
<c>* - Region         : region principal a subdividir</c>
<c>* - Image          : imagen asociada (usada solo para visualizacion opcional)</c>
<c></c>
<c>* SALIDAS (icono):</c>
<c>* - Region_Sup     : subregion superior</c>
<c>* - Region_Inter   : subregion central/intermedia</c>
<c>* - Region_Inf     : subregion inferior</c>
<c>* - Region_Izq     : subregion izquierda</c>
<c>* - Region_Der     : subregion derecha</c>
<c>********************************************************************************</c>
<c></c>
<l>if (false)</l>
<l>    dev_clear_window ()</l>
<l>    dev_display(Image)</l>
<l>    dev_display(Region)</l>
<l>    dev_display(Image)</l>
<l>    gen_arrow_pers (Arrow,RowCentro ,ColCentro ,Phi ,30 ,700 )</l>
<l>endif</l>
<c></c>
<c>* Obtener area, punto central, rotacion y dimensiones</c>
<l>area_center (Region, Area, RowCentro, ColCentro)</l>
<l>region_features (Region, 'orientation', Phi)</l>
<l>region_features (Region, 'rect2_len1', Length_X)</l>
<l>region_features (Region, 'rect2_len2', Length_Y)</l>
<c></c>
<c>* tuple_deg2 fuerza a cuadrante 3 y 4 (sentido de avance)</c>
<l>tuple_deg2 (Phi, Deg)</l>
<c></c>
<c>* transformar tambien el angulo en radianes a los cuadrantes que queremos</c>
<l>tuple_rad (Deg, Phi)</l>
<c></c>
<c>* Deshacer rotacion</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -Phi, RowCentro, ColCentro, HomMat2DRotate)</l>
<l>affine_trans_region (Region, RegionRot, HomMat2DRotate, 'nearest_neighbor')</l>
<c> </c>
<c>* Crear subregiones inferior, intermedia y superior</c>
<l>DivX := 3</l>
<l>DivY := 1</l>
<l>partition_rectangle (RegionRot, RegionPart, (Length_X*2)/DivX, (Length_Y*2)/DivY)</l>
<l>sort_region (RegionPart, SortedRegions, 'first_point', 'true', 'column')</l>
<c></c>
<l>select_obj (SortedRegions, Region_Sup, 1)</l>
<l>select_obj (SortedRegions, Region_Inter, 2)</l>
<l>select_obj (SortedRegions, Region_Inf, 3)</l>
<c></c>
<c>* Crear subregiones izquierda y derecha</c>
<l>DivX := 1</l>
<l>DivY := 2</l>
<l>partition_rectangle (RegionRot, RegionPart, (Length_X*2)/DivX, (Length_Y*2)/DivY)</l>
<l>sort_region (RegionPart, SortedRegions, 'first_point', 'true', 'row')</l>
<c>   </c>
<l>select_obj (SortedRegions, Region_Izq, 2)</l>
<l>select_obj (SortedRegions, Region_Der, 1)</l>
<c></c>
<c>* Rehacer rotacion</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, Phi, RowCentro, ColCentro, HomMat2DRotate)</l>
<c></c>
<l>affine_trans_region (Region_Sup, Region_Sup, HomMat2DRotate, 'nearest_neighbor')</l>
<l>affine_trans_region (Region_Inter, Region_Inter, HomMat2DRotate, 'nearest_neighbor')</l>
<l>affine_trans_region (Region_Inf, Region_Inf, HomMat2DRotate, 'nearest_neighbor')</l>
<l>affine_trans_region (Region_Izq, Region_Izq, HomMat2DRotate, 'nearest_neighbor')</l>
<l>affine_trans_region (Region_Der, Region_Der, HomMat2DRotate, 'nearest_neighbor')</l>
<c></c>
<c>** Visualizacion **</c>
<l>if (false)</l>
<l>    stop()</l>
<l>    dev_clear_window ()</l>
<l>    dev_set_color ('white')</l>
<l>    dev_display (Region)</l>
<l>    dev_set_color ('blue')</l>
<l>    dev_display (Region_Inf)</l>
<l>    dev_display (Region_Inter)</l>
<l>    dev_display (Region_Sup)</l>
<l>    dev_set_color ('green')</l>
<l>    dev_display (Region_Izq)</l>
<l>    dev_display (Region_Der)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="caras">
<parameters>
<parameter id="Image"/>
<parameter id="Region"/>
<parameter id="Region_Der"/>
<parameter id="Region_Inf"/>
<parameter id="Region_Inter"/>
<parameter id="Region_Izq"/>
<parameter id="Region_Sup"/>
</parameters>
</docu>
</procedure>
<procedure name="acotacion">
<interface>
<io>
<par name="borde" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="separacion" base_type="ctrl" dimension="0"/>
<par name="sentido" base_type="ctrl" dimension="0"/>
<par name="distancia" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Acota una linea de contorno visualizando la distancia entre dos puntos</c>
<c>* y dibujando una linea desplazada con sus respectivas lineas auxiliares </c>
<c>* y flechas. La distancia se presenta como texto con formato.</c>
<c></c>
<c>* ENTRADAS (icono):</c>
<c>* - borde       : contorno que representa la linea a acotar</c>
<c></c>
<c>* ENTRADAS (control):</c>
<c>* - separacion  : distancia en pixeles del desplazamiento de la cota</c>
<c>* - sentido     : direccion del desplazamiento (1=arriba, 2=izq, 3=der, 4=abajo)</c>
<c>* - distancia   : valor numerico de la distancia (en mm) que se desea mostrar</c>
<c>********************************************************************************</c>
<c></c>
<c>** Crear linea de acotacion **</c>
<c></c>
<l>dev_set_window (WindowHandle)</l>
<l>dev_set_color ('white')</l>
<c></c>
<c>* Obtener punto inicial y final de linea cota movida</c>
<l>get_contour_xld (borde, Row, Col)</l>
<c></c>
<l>Row1:=Row[0]</l>
<l>Row2:=Row[1]</l>
<l>Col1:=Col[0]</l>
<l>Col2:=Col[1]</l>
<c></c>
<c>* Crear linea de cota</c>
<l>gen_contour_polygon_xld (cota, [Row1,Row2], [Col1,Col2])</l>
<c></c>
<c>* Obtener orientacion</c>
<l>line_orientation (Row1, Col1 ,Row2,Col2,Phi)</l>
<c></c>
<c>** Desplazar linea de acotacion **</c>
<c></c>
<c>* Crear una matriz de transformación afín</c>
<l>hom_mat2d_identity (HomMat2D)</l>
<c></c>
<l>switch (sentido)</l>
<l>case 1:</l>
<c>    * Arriba </c>
<l>    hom_mat2d_translate (HomMat2D, -separacion, 0, HomMat2DTranslated)</l>
<l>    break</l>
<l>case 2:</l>
<c>    * Izquierda</c>
<l>    hom_mat2d_translate (HomMat2D, 0, -separacion, HomMat2DTranslated)</l>
<l>    break</l>
<l>case 3:</l>
<c>    * Derecha</c>
<l>    hom_mat2d_translate (HomMat2D, 0, separacion, HomMat2DTranslated)</l>
<l>    break</l>
<l>case 4:</l>
<c>    * Abajo</c>
<l>    hom_mat2d_translate (HomMat2D, separacion, 0, HomMat2DTranslated)</l>
<l>    break</l>
<l>default:</l>
<l>    throw ('Parametro fuera de rango')</l>
<c>    </c>
<l>endswitch</l>
<c></c>
<c>* Aplicar la transformación al contorno</c>
<l>affine_trans_contour_xld (cota, cota2, HomMat2DTranslated)</l>
<l>dev_display (cota2)</l>
<c></c>
<c>* Obtener punto inicial y final de linea cota movida</c>
<l>get_contour_xld (cota2, Row3, Col3)</l>
<c></c>
<c>** Generar lineas laterales de acotacion **</c>
<l>gen_contour_polygon_xld (Contour1, [Row1,Row3[0]], [Col1,Col3[0]])</l>
<l>gen_contour_polygon_xld (Contour2, [Row2,Row3[1]], [Col2,Col3[1]])</l>
<l>dev_display (Contour1)</l>
<l>dev_display (Contour2)</l>
<c></c>
<c>** Generar flechas **</c>
<l>gen_arrow_contour_xld (Arrow, Row3[0], Col3[0], Row3[1], Col3[1], 50, 30)</l>
<l>dev_display (Arrow)</l>
<l>gen_arrow_contour_xld (Arrow, Row3[1], Col3[1], Row3[0], Col3[0], 50, 30)</l>
<l>dev_display (Arrow)</l>
<c></c>
<c>** Mostrar distancia</c>
<c></c>
<c>* Formatear longitud de segmento</c>
<l>tuple_string (distancia, '.2f', distancia)</l>
<c></c>
<c>* Obtener centro linea</c>
<l>area_center_points_xld (cota2, Area, Row, Col)</l>
<c></c>
<c>* Mostrar texto</c>
<l>switch (sentido)</l>
<l>case 1:</l>
<c>    * Arriba </c>
<l>    dev_disp_text (distancia + ' mm', 'image', Row-50, Col-225, 'black', [], [])</l>
<l>    break</l>
<l>case 2:</l>
<c>    * Izquierda</c>
<l>    dev_disp_text (distancia + ' mm', 'image', Row, Col-300, 'black', [], [])</l>
<l>    break</l>
<l>case 3:</l>
<c>    * Derecha</c>
<l>    dev_disp_text (distancia + ' mm', 'image', Row, Col, 'black', [], [])</l>
<l>    break</l>
<l>case 4:</l>
<c>    * Abajo</c>
<l>    dev_disp_text (distancia + ' mm', 'image', Row, Col-225, 'black', [], [])</l>
<l>    break</l>
<l>default:</l>
<l>    throw ('Parametro fuera de rango')</l>
<l>endswitch</l>
<c></c>
<l>return ()</l>
</body>
<docu id="acotacion">
<parameters>
<parameter id="WindowHandle"/>
<parameter id="borde"/>
<parameter id="distancia"/>
<parameter id="sentido"/>
<parameter id="separacion"/>
</parameters>
</docu>
</procedure>
<procedure name="Normalizar">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Rectangle_Norm" base_type="iconic" dimension="0"/>
<par name="Region_Sup" base_type="iconic" dimension="0"/>
<par name="Region_Inter" base_type="iconic" dimension="0"/>
<par name="Region_Inf" base_type="iconic" dimension="0"/>
<par name="Region_Izq" base_type="iconic" dimension="0"/>
<par name="Region_Der" base_type="iconic" dimension="0"/>
<par name="Bordes_Norm" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="Corner_Rows" base_type="ctrl" dimension="0"/>
<par name="Corner_Cols" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Dado una region binaria de una pieza, segmenta y filtra los bordes</c>
<c>* principales mediante rectas, detecta las esquinas mediante interseccion,</c>
<c>* genera una region rectangular limpia basada en dichas esquinas y </c>
<c>* extrae las subregiones por cara. Incluye validaciones estructurales.</c>
<c>*</c>
<c>* ENTRADAS (icono):</c>
<c>* -Region         : region binaria original de la pieza</c>
<c>* -Image          : imagen original asociada a la region</c>
<c>*</c>
<c>* SALIDAS (icono):</c>
<c>* -Rectangle_Norm : region rectangular generada a partir de las esquinas</c>
<c>* -Region_Sup     : subregion correspondiente a la cara superior</c>
<c>* -Region_Inter   : subregion correspondiente a la cara intermedia</c>
<c>* -Region_Inf     : subregion correspondiente a la cara inferior</c>
<c>* -Region_Izq     : subregion correspondiente a la cara izquierda</c>
<c>* -Region_Der     : subregion correspondiente a la cara derecha</c>
<c>* -Bordes_Norm    : contornos normalizados de los cuatro lados</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* -Corner_Rows    : coordenadas fila de las esquinas detectadas</c>
<c>* -Corner_Cols    : coordenadas columna de las esquinas detectadas</c>
<c>* -Codigo_Error   : 0   = OK</c>
<c>*                   251 = objeto fuera de campo de vision</c>
<c>*********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<c>* Depuracion</c>
<l>if (false)</l>
<l>    dev_clear_window ()</l>
<l>    dev_display (Image)</l>
<l>    dev_display (Region)</l>
<l>    dev_display (Image)</l>
<l>endif</l>
<c></c>
<c>* Calcular orientacion de rectangulo minimo **</c>
<l>smallest_rectangle2 (Region, Row, Column, Ang_Rect_Min, Length1, Length2)</l>
<l>gen_rectangle2 (Rectangle_Min, Row, Column, Ang_Rect_Min, Length1, Length2)</l>
<c></c>
<c>** Subregiones de caras: vista, semivista, no vista **</c>
<l>caras (Rectangle_Min, Image, Region_Sup, Region_Inter, Region_Inf, Region_Izq, Region_Der)</l>
<c></c>
<c>* Contorno de region</c>
<l>gen_contour_region_xld (Region, Contours, 'border')</l>
<c></c>
<c>* Segmentar contornos XLD en segmentos mas pequeños</c>
<l>segment_contours_xld (Contours, ContoursSplit, 'lines_circles', 10, 17, 15)</l>
<c></c>
<c>* Normalizar contornos</c>
<l>fit_line_contour_xld (ContoursSplit, 'tukey', -1, 0, 5, 5, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<c></c>
<l>tuple_length (RowBegin, LengthRowBegin)</l>
<l>tuple_length (RowEnd, LengthRowEnd)</l>
<l>tuple_length (ColBegin, LengthColBegin)</l>
<l>tuple_length (ColEnd, LengthColEnd)</l>
<c></c>
<c>* Generar un array contenedor de los contornos normalizados</c>
<l>gen_empty_obj (norm_contours)</l>
<c></c>
<c>* Valor estimado de tolerancia bordes</c>
<l>tolerance:=rad(5)</l>
<l>pi:=rad(180)</l>
<c></c>
<c>** Filtrado por distancia y angulo **</c>
<l>for Index := 0 to LengthRowBegin-1 by 1</l>
<l>    tuple_select (RowBegin, Index, RowBeginSelected)</l>
<l>    tuple_select (ColBegin, Index, ColBeginSelected)</l>
<c>        </c>
<l>    tuple_select (RowEnd, Index, RowEndSelected)</l>
<l>    tuple_select (ColEnd, Index, ColEndSelected)    </l>
<c>    </c>
<l>    gen_contour_polygon_xld (Contour, [RowBeginSelected,RowEndSelected],[ColBeginSelected,ColEndSelected])</l>
<l>    length_xld (Contour, Length)</l>
<c>    </c>
<c>    ** Filtrado por distancia **</c>
<c>    * Se hace un filtrado de longitud minimo</c>
<c>    * 200 es una estimacion para eliminar bordes pequeños que normalmente corresponden a cortes en la esquinas</c>
<l>    if (Length&gt;200)   </l>
<c>                </c>
<c>        ** Filtrado por angulo**</c>
<c>        * Debe ser paralelo o perpendicular a la orientacion de rectangulo minimo</c>
<c>       </c>
<c>        * Orientacion de borde</c>
<l>        orientation_points_xld (Contour, Ang_Cont)  </l>
<l>        angle_diff:=Ang_Rect_Min-Ang_Cont</l>
<c>        </c>
<c>        * Se normaliza la diferencia real: p ej. enre -170 y 170 es 20 no 340</c>
<l>        Normalizar_Delta (angle_diff, angle_diff_norm)</l>
<c>        </c>
<c>        * Debug</c>
<l>        euler:=deg(angle_diff)</l>
<l>        euler:=deg(angle_diff_norm)    </l>
<c>        </c>
<c>        * Si es un borde perpendicular o paralelo</c>
<l>        angle_diff_norm:=abs(angle_diff_norm)</l>
<l>        is_near_0 := angle_diff_norm &lt;= tolerance</l>
<l>        is_near_90 := abs((angle_diff_norm - pi/2)) &lt;= tolerance</l>
<l>        is_near_180 := abs((angle_diff_norm - pi)) &lt;= tolerance</l>
<c>        </c>
<l>        if (is_near_0 or is_near_90 or is_near_180)</l>
<l>            concat_obj (norm_contours, Contour, norm_contours)</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c>* Se dilatan regiones para detectar bordes</c>
<l>dilation_rectangle1 (Region_Sup, RegionSupDilated, 11, 11)</l>
<l>dilation_rectangle1 (Region_Inf, RegionInfDilated, 11, 11)</l>
<l>dilation_rectangle1 (Region_Izq, RegionIzqDilated, 11, 11)</l>
<l>dilation_rectangle1 (Region_Der, RegionDerDilated, 11, 11)</l>
<c></c>
<c>* Marcas de instanciacion</c>
<l>SupBorderEmpty:=true</l>
<l>InfBorderEmpty:=true</l>
<l>IzqBorderEmpty:=true</l>
<l>DerBorderEmpty:=true</l>
<c></c>
<l>gen_empty_obj (borde_superior)</l>
<l>gen_empty_obj (borde_inferior)</l>
<l>gen_empty_obj (borde_izquierda)</l>
<l>gen_empty_obj (borde_derecha)</l>
<c></c>
<l>count_obj (norm_contours, NumberContours)</l>
<c></c>
<c>** Identificar bordes **</c>
<l>for Index := 1 to NumberContours by 1</l>
<l>    select_obj (norm_contours, Object, Index)</l>
<l>    get_contour_xld (Object, RowIF, ColIF)   </l>
<c>    </c>
<l>    test_region_point (RegionSupDilated, RowIF[0], ColIF[0], IsSupBorder1)</l>
<l>    test_region_point (RegionSupDilated, RowIF[1], ColIF[1], IsSupBorder2)</l>
<c>    </c>
<l>    if (IsSupBorder1 and IsSupBorder2)</l>
<l>        concat_obj (borde_superior, Object, borde_superior)</l>
<l>        SupBorderEmpty:=false</l>
<l>    else</l>
<l>        test_region_point (RegionInfDilated, RowIF[0], ColIF[0], IsInfBorder1)</l>
<l>        test_region_point (RegionInfDilated, RowIF[1], ColIF[1], IsInfBorder2)</l>
<c>        </c>
<l>        if (IsInfBorder1 and IsInfBorder2)</l>
<l>            concat_obj (borde_inferior, Object, borde_inferior)</l>
<l>            InfBorderEmpty:=false</l>
<l>        else  </l>
<l>            test_region_point (RegionIzqDilated, RowIF[0], ColIF[0], IsIzqBorder1)</l>
<l>            test_region_point (RegionIzqDilated, RowIF[1], ColIF[1], IsIzqBorder2)</l>
<c>            </c>
<l>            if (IsIzqBorder1 and IsIzqBorder2)</l>
<l>                concat_obj (borde_izquierda, Object, borde_izquierda)</l>
<l>                IzqBorderEmpty:=false</l>
<l>            else  </l>
<l>                test_region_point (RegionDerDilated, RowIF[0], ColIF[0], IsDerBorder1)</l>
<l>                test_region_point (RegionDerDilated, RowIF[1], ColIF[1], IsDerBorder2)</l>
<c></c>
<l>                if (IsDerBorder1 and IsDerBorder2)</l>
<l>                    concat_obj (borde_derecha, Object, borde_derecha)</l>
<l>                    DerBorderEmpty:=false</l>
<l>                else</l>
<l>                    stop ()</l>
<l>                    throw ('BORDE NO IDENTIFICADO O DOS BORDES ENCONTRADOS EN LA MISMA REGION')</l>
<l>                endif</l>
<l>            endif      </l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c>* Deberia haber bordes en todas las zona</c>
<l>if (SupBorderEmpty or InfBorderEmpty or IzqBorderEmpty or DerBorderEmpty)</l>
<l>    throw ('REGIONES SIN BORDES')    </l>
<l>endif</l>
<c></c>
<c>* Comprobar si hay mas de un borde por region</c>
<c>* En tal caso se ajustan y se hacen 1</c>
<l>count_obj (borde_superior, Number)</l>
<l>if(Number&gt;1)</l>
<l>    Fit_Multiple_Contours (borde_superior, borde_superior, Number)</l>
<l>endif</l>
<c></c>
<l>count_obj (borde_inferior, Number)</l>
<l>if(Number&gt;1)</l>
<l>    Fit_Multiple_Contours (borde_inferior, borde_inferior, Number)</l>
<l>endif</l>
<c></c>
<l>count_obj (borde_izquierda, Number)</l>
<l>if(Number&gt;1)</l>
<l>    Fit_Multiple_Contours (borde_izquierda, borde_izquierda, Number)</l>
<l>endif</l>
<c></c>
<l>count_obj (borde_derecha, Number)</l>
<l>if(Number&gt;1)</l>
<l>    Fit_Multiple_Contours (borde_derecha, borde_derecha, Number)</l>
<l>endif</l>
<c></c>
<c>** Deteccion de intersecciones (esquinas normalizadas)) **</c>
<c></c>
<c>* Inicio y final de bordes identificados</c>
<l>get_contour_xld (borde_superior, RowSup, ColSup)</l>
<l>get_contour_xld (borde_inferior, RowInf, ColInf)   </l>
<l>get_contour_xld (borde_izquierda, RowIzq, ColIzq)   </l>
<l>get_contour_xld (borde_derecha, RowDer, ColDer)   </l>
<c></c>
<c>* Intersecciones</c>
<c></c>
<c>* Esquina1</c>
<l>intersection_lines (RowSup[0], ColSup[0], RowSup[1], ColSup[1], RowIzq[0], ColIzq[0], RowIzq[1], ColIzq[1], Row1, Column1, IsOverlapping1)</l>
<c>* Esquina 2</c>
<l>intersection_lines (RowSup[0], ColSup[0], RowSup[1], ColSup[1], RowDer[0], ColDer[0], RowDer[1], ColDer[1], Row2, Column2, IsOverlapping1)</l>
<c>* Esquina 3</c>
<l>intersection_lines (RowInf[0], ColInf[0], RowInf[1], ColInf[1], RowIzq[0], ColIzq[0], RowIzq[1], ColIzq[1], Row3, Column3, IsOverlapping1)</l>
<c>* Esquina 4</c>
<l>intersection_lines (RowInf[0], ColInf[0], RowInf[1], ColInf[1], RowDer[0], ColDer[0], RowDer[1], ColDer[1], Row4, Column4, IsOverlapping1)</l>
<c></c>
<c>* coordenadas esquinas</c>
<l>Corner_Rows := [Row1,Row2,Row3,Row4]</l>
<l>Corner_Cols := [Column1,Column2,Column3,Column4]</l>
<c></c>
<c>* Crear contornos normalizados completos</c>
<l>gen_contour_polygon_xld (borde_superior, [Row1,Row2], [Column1,Column2])</l>
<l>gen_contour_polygon_xld (borde_inferior, [Row3,Row4], [Column3,Column4])</l>
<l>gen_contour_polygon_xld (borde_izquierda, [Row1,Row3], [Column1,Column3])</l>
<l>gen_contour_polygon_xld (borde_derecha, [Row2,Row4], [Column2,Column4])</l>
<c></c>
<l>gen_empty_obj (Bordes_Norm)</l>
<l>concat_obj (Bordes_Norm, borde_superior, Bordes_Norm)</l>
<l>concat_obj (Bordes_Norm, borde_izquierda, Bordes_Norm)</l>
<l>concat_obj (Bordes_Norm, borde_derecha, Bordes_Norm)</l>
<l>concat_obj (Bordes_Norm, borde_inferior, Bordes_Norm)</l>
<c></c>
<c>* Crear region dentro de bordes normalizados</c>
<l>gen_region_polygon_filled (Rectangle_Norm, [Row1,Row2,Row4,Row3,Row1], [Column1,Column2,Column4,Column3,Column1])</l>
<c></c>
<c>* Comprobar que los bordes normalizados estean dentro de la imagen</c>
<l>image_border (Image, Rectangle_Norm, IsOnBorder)</l>
<c></c>
<l>if (IsOnBorder)</l>
<l>    Codigo_Error:=251</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Normalizar">
<parameters>
<parameter id="Bordes_Norm"/>
<parameter id="Codigo_Error"/>
<parameter id="Corner_Cols"/>
<parameter id="Corner_Rows"/>
<parameter id="Image"/>
<parameter id="Rectangle_Norm"/>
<parameter id="Region"/>
<parameter id="Region_Der"/>
<parameter id="Region_Inf"/>
<parameter id="Region_Inter"/>
<parameter id="Region_Izq"/>
<parameter id="Region_Sup"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_arrow_pers">
<interface>
<oo>
<par name="Arrow" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="Size" base_type="ctrl" dimension="0"/>
<par name="Length" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Genera una flecha a partir de una coordenada central, una direccion (angulo)</c>
<c>* y una longitud definida. La flecha se genera como contorno XLD orientado.</c>
<c></c>
<c>* ENTRADAS (control):</c>
<c>* - Row     : coordenada fila del punto inicial</c>
<c>* - Column  : coordenada columna del punto inicial</c>
<c>* - Angle   : angulo en radianes desde el punto inicial</c>
<c>* - Size    : tamaño de la cabeza de flecha</c>
<c>* - Length  : longitud total de la flecha</c>
<c></c>
<c>* SALIDAS (icono):</c>
<c>* - Arrow   : contorno XLD en forma de flecha</c>
<c>********************************************************************************</c>
<c></c>
<c>* Calcular coordenadas del punto final segun angulo y longitud</c>
<l>RowEnd := Row - Length * sin(Angle)</l>
<l>ColEnd := Column + Length * cos(Angle)</l>
<c></c>
<c>* Generar flecha como contorno XLD</c>
<l>gen_arrow_contour_xld (Arrow, Row, Column, RowEnd, ColEnd, Size, Size)</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="gen_arrow_pers">
<parameters>
<parameter id="Angle"/>
<parameter id="Arrow"/>
<parameter id="Column"/>
<parameter id="Length"/>
<parameter id="Row"/>
<parameter id="Size"/>
</parameters>
</docu>
</procedure>
<procedure name="distancia_mm">
<interface>
<io>
<par name="X" base_type="iconic" dimension="0"/>
<par name="Y" base_type="iconic" dimension="0"/>
<par name="Z" base_type="iconic" dimension="0"/>
<par name="Bordes_Norm" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="row1" base_type="ctrl" dimension="0"/>
<par name="col1" base_type="ctrl" dimension="0"/>
<par name="row2" base_type="ctrl" dimension="0"/>
<par name="col2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="distancia" base_type="ctrl" dimension="0"/>
<par name="distancia_px" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Calcula la distancia en mm entre dos puntos definidos en coordenadas</c>
<c>* de imagen, utilizando las imágenes de escala X e Y. Verifica que la </c>
<c>* configuración de los puntos forme un ángulo recto.</c>
<c>*</c>
<c>* ENTRADAS (icono):</c>
<c>* - X                : imagen con coordenadas X reales</c>
<c>* - Y                : imagen con coordenadas Y reales</c>
<c>* - Z                : imagen de altura (solo para visualización opcional)</c>
<c>* - Bordes_Norm      : contornos de referencia (solo para depuración)</c>
<c></c>
<c>* ENTRADAS (control):</c>
<c>* - row1, col1       : coordenadas del primer punto</c>
<c>* - row2, col2       : coordenadas del segundo punto</c>
<c></c>
<c>* SALIDAS (control):</c>
<c>* - distancia        : distancia calculada en mm</c>
<c>* - distancia_px     : distancia en píxeles</c>
<c>********************************************************************************</c>
<c></c>
<l>if (false)</l>
<c>  </c>
<c>    * Mostar bordes normalizados</c>
<l>    dev_clear_window ()</l>
<l>    dev_display (Z)</l>
<l>    dev_display(Bordes_Norm)</l>
<c>    </c>
<c>    * Generar cruces de angulo rectangulo</c>
<l>    gen_cross_contour_xld (esquina1,row1, col1, 60, 0)</l>
<l>    gen_cross_contour_xld (esquina2,row2, col2, 60, 0)  </l>
<l>    gen_cross_contour_xld (esquina3,row1, col2, 60, 0)  </l>
<c>    </c>
<c>    * Identificar esquinas</c>
<l>    dev_disp_text ('e1', 'image', row1+50, col1-300, 'black', [], [])</l>
<l>    dev_disp_text ('e2', 'image', row2-100, col2+100, 'black', [], [])</l>
<l>    dev_disp_text ('e3', 'image', row1, col2+100, 'black', [], [])</l>
<c>    </c>
<c>    * Generar catetos e hipotenusa</c>
<c>    </c>
<l>    gen_contour_polygon_xld (hipotenusa, [row1,row2], [col1,col2])</l>
<l>    gen_contour_polygon_xld (contiguo, [row1,row1], [col1,col2])</l>
<l>    gen_contour_polygon_xld (opuesto, [row1,row2], [col2,col2])</l>
<c>    </c>
<l>    dev_set_color ('yellow')</l>
<l>    dev_display (hipotenusa)</l>
<l>    dev_display (contiguo)</l>
<l>    dev_display (opuesto)</l>
<l>    dev_set_color ('red')</l>
<c>    </c>
<c>    * Obtener coordenadas para visualizacion</c>
<l>    area_center_points_xld (hipotenusa, Area, Row_hip, Col_hip)</l>
<l>    area_center_points_xld (opuesto, Area, Row_op, Col_op)</l>
<l>    area_center_points_xld (contiguo, Area, Row_cont, Col_cont) </l>
<c>    </c>
<c>    * Visualizacion distancias en pixeles </c>
<l>    dev_disp_text ('Longitud en pixel : ' + distancia_px, 'image', 0, 0, 'black', [], [])</l>
<l>    distance_pp (row1, col1, row1, col2, dist_cont)</l>
<l>    distance_pp (row1, col2, row2, col2, dist_op)</l>
<l>endif</l>
<c>  </c>
<c>* Distancia en pixeles</c>
<l>distance_pp (row1, col1, row2, col2, distancia_px)</l>
<c></c>
<c>* Deberia ser un angulo recto</c>
<l>angle_ll (row1, col1, row1, col2, row2, col2, row1, col2, Angle)</l>
<l>Angle:=deg(Angle)</l>
<c></c>
<l>if (Angle!=90 and Angle!=-90 and Angle!=-0 )</l>
<l>    dev_disp_text ('Suma de angulos incoherente', 'window', 'center', 'center', 'black', [], [])</l>
<l>    stop ()</l>
<l>    throw ('ANGULOS RECTO INCOHERENTE (&lt;&gt;4): ' + Angle + 'GRADOS')</l>
<l>endif</l>
<c>  </c>
<c>** Coordenadas en imagen  X e Y</c>
<c></c>
<c>* escalar coordenadas p1</c>
<l>get_grayval (X, 0, col1, p1x)</l>
<l>get_grayval (Y, row1, 0, p1y)</l>
<c></c>
<c>* escalar coordenadas p2</c>
<l>get_grayval (X, 0, col2, p2x)</l>
<l>get_grayval (Y, row2, 0, p2y)</l>
<c></c>
<c></c>
<c>* calculo de diferencias y distancia final</c>
<l>distancia_x:= p2x-p1x</l>
<l>distancia_y:= p2y-p1y</l>
<c></c>
<l>tuple_sqrt ((distancia_x*distancia_x) + (distancia_y*distancia_y) , distancia)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="distancia_mm">
<parameters>
<parameter id="Bordes_Norm"/>
<parameter id="X"/>
<parameter id="Y"/>
<parameter id="Z"/>
<parameter id="col1"/>
<parameter id="col2"/>
<parameter id="distancia"/>
<parameter id="distancia_px"/>
<parameter id="row1"/>
<parameter id="row2"/>
</parameters>
</docu>
</procedure>
<procedure name="pixel_size">
<interface>
<io>
<par name="X" base_type="iconic" dimension="0"/>
<par name="Y" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="px_x_size" base_type="ctrl" dimension="0"/>
<par name="px_y_size" base_type="ctrl" dimension="0"/>
<par name="px_area" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Calcula las dimensiones y el area de un pixel a partir de las imagenes</c>
<c>* de escala en X e Y.</c>
<c></c>
<c>* ENTRADAS (icono):</c>
<c>* - X          : imagen con valores de coordenadas en X</c>
<c>* - Y          : imagen con valores de coordenadas en Y</c>
<c></c>
<c>* SALIDAS (control):</c>
<c>* - px_x_size  : tamaño del pixel en direccion X [mm]</c>
<c>* - px_y_size  : tamaño del pixel en direccion Y [mm]</c>
<c>* - px_area    : area de un pixel [mm²]</c>
<c>********************************************************************************</c>
<c></c>
<l>if (false) </l>
<l>    dev_display (X)</l>
<l>    dev_display (Y)</l>
<l>endif</l>
<c></c>
<c>* Calculo de tamaño de pixel en direccion X</c>
<l>get_image_size (X, Width, Height)</l>
<l>get_grayval (X, Height-1, 0, p1)</l>
<l>get_grayval (X, Height-1, Width-1, p2)</l>
<c></c>
<l>rango_mm_x := p2-p1</l>
<l>rango_px_x:= Width-1</l>
<l>px_x_size := rango_mm_x/rango_px_x</l>
<c></c>
<c>* Calculo de tamaño de pixel en direccion Y</c>
<l>get_image_size (Y, Width, Height)</l>
<l>get_grayval (Y, 0, Width-1, p1)</l>
<l>get_grayval (Y, Height-1, Width-1, p2)</l>
<c></c>
<l>rango_mm_y := p2-p1</l>
<l>rango_px_y:= Height-1</l>
<l>px_y_size := rango_mm_y/rango_px_y</l>
<c></c>
<c>* Calculo de area de un pixel</c>
<l>px_area:=px_x_size * px_y_size</l>
<l>return ()</l>
</body>
<docu id="pixel_size">
<parameters>
<parameter id="X"/>
<parameter id="Y"/>
<parameter id="px_area"/>
<parameter id="px_x_size"/>
<parameter id="px_y_size"/>
</parameters>
</docu>
</procedure>
<procedure name="Lectura_Canales_PLC">
<interface>
<ic>
<par name="IoDeviceHandle" base_type="ctrl" dimension="0"/>
<par name="DB_PLC" base_type="ctrl" dimension="0"/>
<par name="offline" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Io_Realizar_Vision" base_type="ctrl" dimension="0"/>
<par name="Io_Espesor_Nominal" base_type="ctrl" dimension="0"/>
<par name="Io_Cargar_Fichero_1" base_type="ctrl" dimension="0"/>
<par name="Io_Cargar_Fichero_2" base_type="ctrl" dimension="0"/>
<par name="Io_Control_Esquinas_1" base_type="ctrl" dimension="0"/>
<par name="Io_Control_Esquinas_2" base_type="ctrl" dimension="0"/>
<par name="Io_Control_Perforaciones_1" base_type="ctrl" dimension="0"/>
<par name="Io_Control_Perforaciones_2" base_type="ctrl" dimension="0"/>
<par name="Io_Produccion" base_type="ctrl" dimension="0"/>
<par name="Io_ID_Pizarra_In" base_type="ctrl" dimension="0"/>
<par name="Io_Codigo_Error" base_type="ctrl" dimension="0"/>
<par name="Io_Vision_Realizada" base_type="ctrl" dimension="0"/>
<par name="Io_Largo_Medido" base_type="ctrl" dimension="0"/>
<par name="Io_Ancho_Medido" base_type="ctrl" dimension="0"/>
<par name="Io_Espesor_Medido" base_type="ctrl" dimension="0"/>
<par name="Io_Tercio_Visible" base_type="ctrl" dimension="0"/>
<par name="Io_Calidad_Tercio_1" base_type="ctrl" dimension="0"/>
<par name="Io_Calidad_Tercio_3" base_type="ctrl" dimension="0"/>
<par name="Io_Fichero_Cargado_1" base_type="ctrl" dimension="0"/>
<par name="Io_Fichero_Cargado_2" base_type="ctrl" dimension="0"/>
<par name="Io_ID_Pizarra_Out" base_type="ctrl" dimension="0"/>
<par name="Io_ID_Produccion_1" base_type="ctrl" dimension="0"/>
<par name="Io_ID_Produccion_2" base_type="ctrl" dimension="0"/>
<par name="Io_LiveBit_In" base_type="ctrl" dimension="0"/>
<par name="Io_LiveBit_Out" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Abre los canales de comunicacion OPC UA entre HALCON y el PLC. Asocia</c>
<c>* variables del programa con nodos del espacio de nombres en el PLC. Si</c>
<c>* se esta en modo offline, inicializa todos los canales a cero.</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* -IoDeviceHandle      : handle del dispositivo OPC UA</c>
<c>* -DB_PLC              : nombre del bloque de datos del PLC (como string)</c>
<c>* -offline             : flag de simulacion sin comunicacion (1 = offline)</c>
<c>*</c>
<c>* SALIDAS (control):        </c>
<c>* -Io_Realizar_Vision        : canal OPC realizar vision</c>
<c>* -Io_Espesor_Nominal        : canal OPC espesor nominal</c>
<c>* -Io_Cargar_Fichero_1       : canal OPC cargar fichero apilador 1</c>
<c>* -Io_Cargar_Fichero_2       : canal OPC cargar fichero apilador 2</c>
<c>* -Io_Control_Esquinas_1     : canal OPC activar control esquinas apilador 1</c>
<c>* -Io_Control_Esquinas_2     : canal OPC activar control esquinas apilador 2</c>
<c>* -Io_Control_Perforaciones_1: canal OPC produccion 1 con perforaciones</c>
<c>* -Io_Control_Perforaciones_2: canal OPC produccion 2 con perforaciones</c>
<c>* -Io_Produccion             : canal OPC apilador ciclo actual</c>
<c>* -Io_ID_Pizarra_In          : canal OPC ID de pizarra</c>
<c>* -Io_Codigo_Error           : canal OPC codigo de error</c>
<c>* -Io_Vision_Realizada       : canal OPC vision realizada</c>
<c>* -Io_Largo_Medido           : canal OPC largo medido</c>
<c>* -Io_Ancho_Medido           : canal OPC ancho medido</c>
<c>* -Io_Espesor_Medido         : canal OPC espesor medido</c>
<c>* -Io_Tercio_Visible         : canal OPC tercio seleccionado para parte visible</c>
<c>* -Io_Calidad_Tercio_1       : canal OPC calidad de tercio 1 (primero en pasar fotocelula)</c>
<c>* -Io_Calidad_Tercio_3       : canal OPC calidad de tercio 3 (ultimo en pasar fotocelula)</c>
<c>* -Io_Fichero_Cargado_1      : canal OPC fichero cargado apilador 1</c>
<c>* -Io_Fichero_Cargado_2      : canal OPC fichero cargado apilador 2</c>
<c>* -Io_ID_Pizarra_Out         : canal OPC echo ID pizarra</c>
<c>* -Io_ID_Produccion_1        : canal OPC echo ID fichero apilador 1</c>
<c>* -Io_ID_Produccion_2        : canal OPC echo ID fichero apilador 2</c>
<c>* -Io_LiveBit_In             : bit de vida entrada</c>
<c>* -Io_LiveBit_Out            : bit de vida salida</c>
<c>* -Codigo_Error              : 0 = OK</c>
<c>*                            : 9998 = error lectura canales OPC UA</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<l>if (offline == 0)</l>
<l>    try</l>
<c></c>
<c>        * **** ### SALIDAS PLC - ENTRADAS HALCON ### *****</c>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."SALIDAS"."Realizar_Vision"', [], [], Io_Realizar_Vision)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."SALIDAS"."Espesor_Nominal"', [], [], Io_Espesor_Nominal)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."SALIDAS"."Cargar_Fichero_1"', [], [], Io_Cargar_Fichero_1)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."SALIDAS"."Cargar_Fichero_2"', [], [], Io_Cargar_Fichero_2)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."SALIDAS"."Control_Esquinas_1"', [], [], Io_Control_Esquinas_1)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."SALIDAS"."Control_Esquinas_2"', [], [], Io_Control_Esquinas_2)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."SALIDAS"."Control_Perforaciones_1"', [], [], Io_Control_Perforaciones_1)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."SALIDAS"."Control_Perforaciones_2"', [], [], Io_Control_Perforaciones_2)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."SALIDAS"."Produccion"', [], [], Io_Produccion)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."SALIDAS"."ID_Pizarra"', [], [], Io_ID_Pizarra_In)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."SALIDAS"."LiveBit"', [], [], Io_LiveBit_In)</l>
<c>        </c>
<c>        * **** ### ENTRADAS PLC - SALIDAS HALCON ### *****</c>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."ENTRADAS"."COD_Error"', [], [], Io_Codigo_Error)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."ENTRADAS"."Vision_Realizada"', [], [], Io_Vision_Realizada)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."ENTRADAS"."Largo_Medido"', [], [], Io_Largo_Medido)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."ENTRADAS"."Ancho_Medido"', [], [], Io_Ancho_Medido)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."ENTRADAS"."Espesor_Medido"', [], [], Io_Espesor_Medido)        </l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."ENTRADAS"."Tercio_Visible"', [], [], Io_Tercio_Visible)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."ENTRADAS"."Calidad_Tercio_1"', [], [], Io_Calidad_Tercio_1)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."ENTRADAS"."Calidad_Tercio_3"', [], [], Io_Calidad_Tercio_3)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."ENTRADAS"."Fichero_Cargado_1"', [], [], Io_Fichero_Cargado_1)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."ENTRADAS"."Fichero_Cargado_2"', [], [], Io_Fichero_Cargado_2)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."ENTRADAS"."ID_Pizarra"', [], [], Io_ID_Pizarra_Out)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."ENTRADAS"."ID_Produccion_1"', [], [], Io_ID_Produccion_1)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."ENTRADAS"."ID_Produccion_2"', [], [], Io_ID_Produccion_2)</l>
<l>        open_io_channel (IoDeviceHandle, 'ns=3;s="' + DB_PLC + '"."ENTRADAS"."LiveBit"', [], [], Io_LiveBit_Out)        </l>
<c>        </c>
<l>    catch (ExceptionLecturaCanales)</l>
<c>        </c>
<c>        * Error lectura canales OPC UA</c>
<l>        Codigo_Error := 9998</l>
<l>    endtry</l>
<c></c>
<l>else</l>
<c>    * Simulacion en modo offline: inicializar todos los canales a cero</c>
<c>    </c>
<c>    * **** ### SALIDAS PLC - ENTRADAS HALCON ### *****</c>
<l>    Io_Realizar_Vision:=0</l>
<l>    Io_Espesor_Nominal:=0</l>
<l>    Io_Cargar_Fichero_1:=0</l>
<l>    Io_Cargar_Fichero_2:=0</l>
<l>    Io_Control_Esquinas_1:=0</l>
<l>    Io_Control_Esquinas_2:=0</l>
<l>    Io_Control_Perforaciones_1:=0</l>
<l>    Io_Control_Perforaciones_2:=0</l>
<l>    Io_Produccion:=0</l>
<l>    Io_ID_Pizarra_In:=0</l>
<l>    Io_ID_Produccion_1:=0</l>
<l>    Io_ID_Produccion_2:=0</l>
<l>    Io_LiveBit_In:=0</l>
<c>    </c>
<c>    * **** ### ENTRADAS PLC - SALIDAS HALCON ### *****</c>
<l>    Io_Codigo_Error:=0</l>
<l>    Io_Vision_Realizada:=0</l>
<l>    Io_Largo_Medido:=0</l>
<l>    Io_Ancho_Medido:=0</l>
<l>    Io_Espesor_Medido:=0       </l>
<l>    Io_Tercio_Visible:=0</l>
<l>    Io_Calidad_Tercio_1:=0</l>
<l>    Io_Calidad_Tercio_3:=0</l>
<l>    Io_Fichero_Cargado_1:=0</l>
<l>    Io_Fichero_Cargado_2:=0</l>
<l>    Io_ID_Pizarra_Out:=0</l>
<l>    Io_ID_Produccion_1:=0</l>
<l>    Io_ID_Produccion_2:=0</l>
<l>    Io_LiveBit_Out:=0</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Lectura_Canales_PLC">
<parameters>
<parameter id="Codigo_Error"/>
<parameter id="DB_PLC"/>
<parameter id="IoDeviceHandle"/>
<parameter id="Io_Ancho_Medido"/>
<parameter id="Io_Calidad_Tercio_1"/>
<parameter id="Io_Calidad_Tercio_3"/>
<parameter id="Io_Cargar_Fichero_1"/>
<parameter id="Io_Cargar_Fichero_2"/>
<parameter id="Io_Codigo_Error"/>
<parameter id="Io_Control_Esquinas_1"/>
<parameter id="Io_Control_Esquinas_2"/>
<parameter id="Io_Control_Perforaciones_1"/>
<parameter id="Io_Control_Perforaciones_2"/>
<parameter id="Io_Espesor_Medido"/>
<parameter id="Io_Espesor_Nominal"/>
<parameter id="Io_Fichero_Cargado_1"/>
<parameter id="Io_Fichero_Cargado_2"/>
<parameter id="Io_ID_Pizarra_In"/>
<parameter id="Io_ID_Pizarra_Out"/>
<parameter id="Io_ID_Produccion_1"/>
<parameter id="Io_ID_Produccion_2"/>
<parameter id="Io_Largo_Medido"/>
<parameter id="Io_LiveBit_In"/>
<parameter id="Io_LiveBit_Out"/>
<parameter id="Io_Produccion"/>
<parameter id="Io_Realizar_Vision"/>
<parameter id="Io_Tercio_Visible"/>
<parameter id="Io_Vision_Realizada"/>
<parameter id="offline"/>
</parameters>
</docu>
</procedure>
<procedure name="Visualizacion_Celda">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Celda" base_type="ctrl" dimension="0"/>
<par name="Version" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Muestra informacion contextual sobre la ejecucion actual: numero de celda,</c>
<c>* version del sistema, numero de ciclo y fecha/hora actual del sistema. </c>
<c>* Se visualiza en la ventana activa.</c>
<c></c>
<c>* ENTRADAS (control):</c>
<c>* - WindowHandle : identificador de la ventana de visualizacion</c>
<c>* - Celda        : nombre o codigo identificador de la celda</c>
<c>* - Version      : version del sistema o del software</c>
<c>* </c>
<c>* SALIDAS (control):</c>
<c>* - Codigo_Error: reserva</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<l>dev_set_window (WindowHandle)</l>
<c></c>
<c>* Ajustar fuente para cabecera</c>
<l>set_display_font (WindowHandle, 14, 'mono', 'true', 'false')</l>
<c></c>
<c>* Mostrar version y celda en parte superior de la ventana</c>
<l>dev_disp_text ('VERSION : ' + Version, 'window', 'top', 'left', 'black', [], [])</l>
<l>dev_disp_text ('CELDA : ' + Celda, 'window', 'top', 350, 'black', [], [])</l>
<c></c>
<c>* Obtener fecha y hora actual del sistema</c>
<l>get_system_time (MSecond, Second, Minute, Hour, Day, YDay, Month, Year)</l>
<c></c>
<c>* Mostrar fecha y hora en parte inferior izquierda</c>
<l>dev_disp_text (Year + '/' + Month + '/' + Day + ' ' + Hour + ':' + Minute + ':' +Second, 'window', 'bottom', 'left', 'forest green', [], [])</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Visualizacion_Celda">
<parameters>
<parameter id="Celda"/>
<parameter id="Version"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="Conexion_Camara">
<interface>
<ic>
<par name="PATH" base_type="ctrl" dimension="0"/>
<par name="offline" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Celda" base_type="ctrl" dimension="0"/>
<par name="Version" base_type="ctrl" dimension="0"/>
<par name="ciclo" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Inicializa la camara 3D GenICam, establece conexion y muestra mensajes</c>
<c>* de estado en la ventana de visualizacion. Si esta en modo offline, simula</c>
<c>* la conexion para continuar el flujo del programa sin hardware.</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* -PATH         : ruta general del proyecto (no utilizado directamente aqui)</c>
<c>* -offline      : flag de simulacion sin hardware (0 = activo, 1 = simulacion)</c>
<c>* -WindowHandle : handle de la ventana de visualizacion</c>
<c>* -Celda        : nombre o identificador de celda (para mostrar en pantalla)</c>
<c>* -Version      : version del sistema o del ciclo</c>
<c>* -ciclo        : numero de ciclo o iteracion del proceso</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* -AcqHandle    : handle del grabber de adquisicion abierto (o 0 en offline)</c>
<c>* -Codigo_Error : 0   = OK</c>
<c>*               : 206 = error conexion camara</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<c>* Obtener y limpiar la ventana</c>
<l>dev_get_window (WindowHandle)</l>
<l>dev_clear_window ()</l>
<c></c>
<c></c>
<c>* Visualizar información inicial</c>
<l>Visualizacion_Celda (WindowHandle, Celda, Version)</l>
<l>dev_disp_text ('COMUNICANDO CON PLC', 'window', 100, 'center', 'black', [], [])</l>
<l>dev_disp_text ('COMUNICACIÓN REALIZADA', 'window', 145, 'center', 'forest green', [], [])</l>
<l>dev_disp_text ('INICIANDO CÁMARA 3D...', 'window', 200, 'center', 'black', [], [])</l>
<l>wait_seconds (0.5)</l>
<c></c>
<c>*********************** -- INICIALIZACION DE LA CAMARA -- ***********************</c>
<c></c>
<l>if (offline == 0)</l>
<c>    </c>
<c>    * Cerrar conexión previa si existe</c>
<l>    try</l>
<l>        close_framegrabber (AcqHandle)</l>
<l>    catch (Exception)</l>
<l>    endtry</l>
<c>    </c>
<l>    try</l>
<c>        </c>
<c>        * Apertura del grabber con la configuración GenICamTL</c>
<l>        open_framegrabber ('GenICamTL', 0, 0, 0, 0, 0, 0, 'progressive', 16, 'rgb', -1, 'false', 'default', '172.31.1.10', 0, -1, AcqHandle)</l>
<l>*         open_framegrabber ('GenICamTL', 0, 0, 0, 0, 0, 0, 'progressive', -1, 'default', -1, 'false', 'default', '127.0.0.1:3190', 0, -1, AcqHandle)    </l>
<c>        </c>
<c>        * Iniciar adquisición</c>
<c>        * Image Acquisition 01: Attention: The parameterization may fail in case parameters need to</c>
<c>        * Image Acquisition 01: be set in a specific order (e.g., image resolution vs. offset).</c>
<l>        grab_image_start (AcqHandle, -1)</l>
<c>        </c>
<c>        * Mostrar mensaje de éxito</c>
<l>        set_display_font (WindowHandle, 24, 'mono', 'true', 'false')</l>
<l>        dev_disp_text ('CAMARA CONECTADA', 'window', 250, 'center', 'forest green', [], [])</l>
<c>        </c>
<l>    catch (Exception)</l>
<c>        </c>
<c>        * Error conexion camara</c>
<l>        Codigo_Error := 206</l>
<l>        set_display_font (WindowHandle, 24, 'mono', 'true', 'false')</l>
<l>        dev_disp_text ('ERROR COMUNICACION CAMARA', 'window', 250, 'center', 'red', [], [])</l>
<c>        </c>
<c>        * Mostrar mensaje de excepción</c>
<l>        set_display_font (WindowHandle, 12, 'mono', 'true', 'false')</l>
<l>        dev_disp_text (Exception, 'window', 300, 'center', 'red', [], [])</l>
<l>    endtry</l>
<c>    </c>
<l>else</l>
<c>    </c>
<c>    * Modo offline: simulación sin cámara</c>
<l>    AcqHandle := 0</l>
<l>    set_display_font (WindowHandle, 24, 'mono', 'true', 'false')</l>
<l>    dev_disp_text ('OFFLINE', 'window', 250, 'center', 'forest green', [], [])</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Conexion_Camara">
<parameters>
<parameter id="AcqHandle"/>
<parameter id="Celda"/>
<parameter id="Codigo_Error"/>
<parameter id="PATH">
<sem_type>string</sem_type>
</parameter>
<parameter id="Version"/>
<parameter id="WindowHandle"/>
<parameter id="ciclo"/>
<parameter id="offline"/>
</parameters>
</docu>
</procedure>
<procedure name="Variables_Celda">
<interface>
<oc>
<par name="Celda" base_type="ctrl" dimension="0"/>
<par name="IP_PLC" base_type="ctrl" dimension="0"/>
<par name="DB_PLC" base_type="ctrl" dimension="0"/>
<par name="Ruta_Imagenes" base_type="ctrl" dimension="0"/>
<par name="Ruta_Config" base_type="ctrl" dimension="0"/>
<par name="Ruta_Offline" base_type="ctrl" dimension="0"/>
<par name="Ruta_HMI" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Lee parametros de configuracion general desde un archivo de texto plano</c>
<c>* ('datos_vision.txt') y los asigna a variables globales de control para</c>
<c>* su uso en el sistema de vision. En caso de fallo o ausencia del archivo,</c>
<c>* devuelve un codigo de error.</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* - (ninguna)</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* - Celda         : identificador de celda (p. ej. 'CELDA_1')</c>
<c>* - IP_PLC        : direccion IP del PLC</c>
<c>* - Codigo_Error  : 0 = OK, 107 = error lectura interna, 108 = archivo no encontrado</c>
<c>* - DB_PLC        : nombre del bloque de datos del PLC</c>
<c>* - Ruta_Imagenes : ruta base para guardar imagenes</c>
<c>* - Ruta_Config   : ruta base de configuracion</c>
<c>* - Ruta_Offline  : ruta para modo offline (simulacion)</c>
<c>* - Ruta_HMI      : ruta de salida para la interfaz HMI</c>
<c>* - Codigo_Error  : 0   = OK</c>
<c>*                   200 = error general carga variables de celda</c>
<c>*                   201 = archivo de variables de celda no encontrado</c>
<c>*                   202 = error durante la extraccion de variables de celda</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<c>* Inicializar listas de almacenamiento</c>
<l>variables := []</l>
<l>valores := []</l>
<c></c>
<l>try</l>
<c>    </c>
<c>     * Verificar si existe el archivo de configuracion</c>
<l>    file_exists ('datos_vision.txt', FileExists)</l>
<c></c>
<l>    if (FileExists == 1)</l>
<c></c>
<c>        * Abrir el archivo en modo lectura</c>
<l>        open_file ('./datos_vision.txt', 'input', FileHandle)</l>
<c></c>
<c>        * Leer linea por linea hasta el final</c>
<l>        while (true)</l>
<l>            fread_line (FileHandle, OutLine, IsEOF)    </l>
<c>            </c>
<c>            * Solo procesar lineas no vacias</c>
<l>            if (OutLine != '')</l>
<c></c>
<c>                * Quitar saltos de linea residuales</c>
<l>                tuple_split (OutLine, '\n', V)</l>
<c>                </c>
<c>                * Separar clave y valor por el signo '='</c>
<l>                tuple_split (V, '=', V)</l>
<c>                </c>
<c>                * Insertar clave y valor en sus listas respectivas</c>
<l>                tuple_insert (variables, 0, V[0], variables)</l>
<l>                tuple_insert (valores, 0, V[1], valores)</l>
<l>            else</l>
<c>                </c>
<c>                * Finalizar si la linea esta vacia</c>
<l>                break</l>
<l>            endif</l>
<l>        endwhile</l>
<c></c>
<l>        try</l>
<c>             * Buscar e insertar los valores en las variables de salida</c>
<l>            tuple_find (variables, 'CELDA', I_celda)</l>
<l>            Celda := valores[I_celda]</l>
<c></c>
<l>            tuple_find (variables, 'IP', I_IP)</l>
<l>            IP_PLC := valores[I_IP]</l>
<c></c>
<l>            tuple_find (variables, 'DB_PLC', I_db)</l>
<l>            DB_PLC := valores[I_db]</l>
<c></c>
<l>            tuple_find (variables, 'RUTA_CONFIG', I_Config)</l>
<l>            Ruta_Config := valores[I_Config]</l>
<c></c>
<l>            tuple_find (variables, 'RUTA_IMAGENES_CAL', I_Im_Cal)</l>
<l>            Ruta_Imagenes_Cal := valores[I_Im_Cal]</l>
<c></c>
<l>            tuple_find (variables, 'RUTA_IMAGENES', I_Im)</l>
<l>            Ruta_Imagenes := valores[I_Im]</l>
<c></c>
<l>            tuple_find (variables, 'RUTA_OFFLINE', I_Off)</l>
<l>            Ruta_Offline := valores[I_Off]</l>
<c>            </c>
<l>            tuple_find (variables, 'RUTA_HMI', I_Off)</l>
<l>            Ruta_HMI := valores[I_Off]          </l>
<c>            </c>
<l>        catch (Exception)</l>
<c>            </c>
<c>            * Error durante la extraccion de variables de celda</c>
<l>            Codigo_Error := 202</l>
<l>        endtry</l>
<c></c>
<l>        close_file (FileHandle)</l>
<l>    else</l>
<c>        </c>
<c>        * Archivo de variables de celda no encontrado</c>
<l>        Codigo_Error := 201</l>
<l>    endif</l>
<c></c>
<l>catch (Exception)</l>
<c>    </c>
<c>    * Error general carga variables de celda</c>
<l>    Codigo_Error := 200</l>
<l>endtry</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Variables_Celda">
<parameters>
<parameter id="Celda"/>
<parameter id="Codigo_Error"/>
<parameter id="DB_PLC"/>
<parameter id="IP_PLC"/>
<parameter id="Ruta_Config"/>
<parameter id="Ruta_HMI"/>
<parameter id="Ruta_Imagenes"/>
<parameter id="Ruta_Offline"/>
</parameters>
</docu>
</procedure>
<procedure name="Conexion_PLC">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="IP" base_type="ctrl" dimension="0"/>
<par name="Celda" base_type="ctrl" dimension="0"/>
<par name="reset_comunicacion" base_type="ctrl" dimension="0"/>
<par name="Version" base_type="ctrl" dimension="0"/>
<par name="offline" base_type="ctrl" dimension="0"/>
<par name="ciclo" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IoDeviceHandle" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Establece la conexion con el PLC mediante OPC UA. Si no esta en modo</c>
<c>* offline, intenta conectarse dos veces antes de reportar un error. En</c>
<c>* caso de fallo se visualiza el error en pantalla y se guarda una imagen</c>
<c>* del problema para diagnostico.</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* -WindowHandle      : handle de la ventana de visualizacion</c>
<c>* -IP                : direccion IP del servidor OPC UA (PLC)</c>
<c>* -Celda             : nombre o identificador de celda (para mostrar en pantalla)</c>
<c>* -rest_comunicacion : parametro de control externo (sin uso directo aqui)</c>
<c>* -Version           : version del sistema o del ciclo</c>
<c>* -offline           : flag de simulacion sin conexion (1 = offline)</c>
<c>* -ciclo             : numero de ciclo actual</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* -IoDeviceHandle    : handle del dispositivo OPC UA abierto</c>
<c>* -Codigo_Error      : 0    = OK</c>
<c>*                      9999 = error de comunicación PC-PLC</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<c>* Componer la URL del servidor OPC UA</c>
<l>MyOpcUaServer := IP</l>
<l>MyOpcUaPortNumber := 4840</l>
<l>MyOpcUaServer := 'opc.tcp://' + MyOpcUaServer + ':' + MyOpcUaPortNumber</l>
<c></c>
<c>* Limpia la ventana y muestra estado inicial</c>
<l>dev_clear_window ()</l>
<l>Visualizacion_Celda (WindowHandle, Celda, Version)</l>
<l>set_display_font (WindowHandle, 24, 'mono', 'true', 'false')</l>
<l>dev_disp_text ('COMUNICANDO CON PLC', 'window', 100, 'center', 'black', [], [])</l>
<c></c>
<l>if (offline== 0)</l>
<c>    </c>
<c>    * Intenta conectar con el PLC hasta 2 veces</c>
<l>    for i := 1 to 2 by 1</l>
<l>        try</l>
<c>            </c>
<c>            * Abrir dispositivo OPC UA</c>
<l>            open_io_device ('OPC_UA', MyOpcUaServer, ['connect_timeout'], [5000], IoDeviceHandle)</l>
<c>            </c>
<c>            * Comunicacion exitosa</c>
<l>            set_display_font (WindowHandle, 24, 'mono', 'true', 'false')</l>
<l>            dev_disp_text ('COMUNICACION REALIZADA', 'window', 145, 'center', 'forest green', [], [])</l>
<c>            </c>
<l>            break</l>
<c>            </c>
<l>        catch (ExceptionComunicacionPLC)</l>
<c>            </c>
<c>            * Error de comunicacion PC-PLC, reportado solo en segundo intento</c>
<c>            * 9999: Error de comunicación PC-PLC (Como el PLC no puede tener conocimiento de este erros no se incluye en la lista)</c>
<l>            if (i==2)</l>
<c>                </c>
<c>                * Error de comunicación PC-PLC</c>
<l>                Codigo_Error := 9999</l>
<l>                set_display_font (WindowHandle, 24, 'mono', 'true', 'false')</l>
<l>                dev_disp_text ('ERROR COMUNICACION CON PLC', 'window', 175, 'center', 'red', [], [])</l>
<c>                </c>
<c>                * Mostrar detalle de excepcion</c>
<l>                set_display_font (WindowHandle, 9, 'mono', 'true', 'false')</l>
<c>                </c>
<c>                * Capturar imagen y guardar para diagnostico</c>
<l>                dev_disp_text (ExceptionComunicacionPLC, 'window', 300, 'center', 'red', [], [])</l>
<l>                dump_window_image (Image, WindowHandle)</l>
<l>                Guardar_Img_Errores (Image, '../IMAGENES/ERRORS/')</l>
<l>            endif</l>
<l>        endtry</l>
<l>    endfor</l>
<c>    </c>
<l>else</l>
<c>    * En modo offline, no se conecta</c>
<l>    dev_disp_text ('OFFLINE', 'window', 140, 'center', 'forest green', [], [])</l>
<l>    IoDeviceHandle := 0</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Conexion_PLC">
<parameters>
<parameter id="Celda"/>
<parameter id="Codigo_Error"/>
<parameter id="IP"/>
<parameter id="IoDeviceHandle"/>
<parameter id="Version"/>
<parameter id="WindowHandle"/>
<parameter id="ciclo"/>
<parameter id="offline"/>
<parameter id="reset_comunicacion"/>
</parameters>
</docu>
</procedure>
<procedure name="Guardar_Img_Errores">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="path" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Guarda una imagen en formato JPEG con marca de tiempo en el nombre.</c>
<c>* Si el directorio contiene mas de 5000 imagenes, elimina la mas antigua</c>
<c>* antes de guardar. Si el directorio no existe, muestra un mensaje de error.</c>
<c>*</c>
<c>* ENTRADAS (icono):</c>
<c>* -Image : imagen a guardar</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* -path  : ruta del directorio donde guardar la imagen (termina en '/')</c>
<c>********************************************************************************</c>
<c></c>
<c>* Obtener fecha y hora actual</c>
<l>get_system_time (MSecond, Second, Minute, Hour, Day, YDay, Month, Year)</l>
<l>tuple_string (Day, '.2d', Day)</l>
<l>tuple_string (Month, '.2d', Month)</l>
<l>tuple_string (Hour, '.2d', Hour)</l>
<l>tuple_string (Minute, '.2d', Minute)</l>
<l>tuple_string (Second, '.2d', Second)</l>
<c></c>
<c>* Formatear marca de tiempo</c>
<l>now := Year + '_' + Month + '_' + Day + '(' + Hour + '_' + Minute + '_' + Second + ')'</l>
<c></c>
<c>* Listar archivos existentes en el directorio</c>
<l>try</l>
<l>    list_image_files (path, 'jpg', [], Files)</l>
<l>catch (Exception)</l>
<l>    dev_get_window (WindowHandle)</l>
<l>set_display_font (WindowHandle, 24, 'mono', 'true', 'false')</l>
<c></c>
<c>    * Si no existe el directorio, mostrar error</c>
<l>    dev_disp_text ('Error guardado Imagenes', 'window', 'center', 'center', 'red', [], [])</l>
<l>    dev_disp_text ('No existe directorio: ' + path, 'window', 375, 'center', 'red', [], [])</l>
<l>    wait_seconds (2)</l>
<l>    return ()</l>
<l>endtry</l>
<c></c>
<l>tuple_length (Files, Length)</l>
<c></c>
<l>if (Length &gt; 5000)</l>
<c>    </c>
<c>    * Eliminar el archivo mas antiguo</c>
<l>    tuple_sort (Files, Sorted)</l>
<l>    try</l>
<l>        delete_file (Sorted[0])</l>
<l>        path := path + now</l>
<l>        write_image (Image, 'jpeg 60', 0, path)</l>
<l>    catch (Exception)</l>
<l>    endtry</l>
<c></c>
<l>else</l>
<c>    </c>
<c>    * Guardar la imagen directamente</c>
<l>    path := path + now</l>
<l>    try</l>
<l>        write_image (Image, 'jpeg 60', 0, path)</l>
<l>    catch (Exception)</l>
<l>    endtry</l>
<c></c>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Guardar_Img_Errores">
<parameters>
<parameter id="Image"/>
<parameter id="path"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_update_off">
<interface/>
<body>
<c>* DESCRIPCION:</c>
<c>* Desactiva las actualizaciones del entorno de desarrollo HDevelop</c>
<c>* para mejorar el rendimiento y reducir la sobrecarga en ejecuciones.</c>
<c>********************************************************************************</c>
<c></c>
<l>dev_update_pc ('off')</l>
<l>dev_update_var ('off')</l>
<l>dev_update_window ('off')</l>
<l>return ()</l>
</body>
<docu id="dev_update_off">
<abstract lang="en_US">This procedure sets the parameter ```DisplayMode``` of &lt;op:dev_update_pc&gt;, &lt;op:dev_update_var&gt; and &lt;op:dev_update_window&gt; to *'off'*.</abstract>
<alternatives>
<item>dev_update_pc</item>
<item>dev_update_var</item>
<item>dev_update_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<chapters lang="ja_JP">
<item>開発</item>
</chapters>
<example lang="en_US">dev_update_off ()
* do something
dev_update_on ()</example>
<keywords lang="de_DE">
<item>Aktualisierungsmodus setzen</item>
</keywords>
<keywords lang="en_US">
<item>set update mode</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_update_on</item>
</see_also>
<short lang="en_US">Switch dev_update_pc, dev_update_var, and dev_update_window to 'off'.</short>
<parameters/>
</docu>
</procedure>
<procedure name="Go2GenTL_ParseData">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="HeightMap" base_type="iconic" dimension="0"/>
<par name="Intensity" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Index" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="FrameCount" base_type="ctrl" dimension="0"/>
<par name="Timestamp" base_type="ctrl" dimension="0"/>
<par name="EncoderPosition" base_type="ctrl" dimension="0"/>
<par name="EncoderIndex" base_type="ctrl" dimension="0"/>
<par name="Inputs" base_type="ctrl" dimension="0"/>
<par name="xOffset" base_type="ctrl" dimension="0"/>
<par name="xResolution" base_type="ctrl" dimension="0"/>
<par name="yOffset" base_type="ctrl" dimension="0"/>
<par name="yResolution" base_type="ctrl" dimension="0"/>
<par name="zOffset" base_type="ctrl" dimension="0"/>
<par name="zResolution" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Length" base_type="ctrl" dimension="0"/>
<par name="HasIntensity" base_type="ctrl" dimension="0"/>
<par name="NumScans" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION :</c>
<c>* Extrae y separa los datos codificados en una imagen generada por</c>
<c>* un sensor Gocator utilizando GenTL. Se extraen la imagen de altura,</c>
<c>* intensidad (si existe), y los metadatos codificados en la ultima fila</c>
<c>* o canal de la imagen, dependiendo del numero de canales.</c>
<c>*</c>
<c>* ENTRADAS</c>
<c>* - Image       : imagen original proveniente del sensor Gocator</c>
<c>* - Index       : indice de la medicion a extraer (usado si hay multiples)</c>
<c>*</c>
<c>* SALIDAS</c>
<c>* - HeightMap       : imagen de altura (mapa de elevacion)</c>
<c>* - Intensity       : imagen de intensidad si aplica, o imagen constante</c>
<c>* - Stamps          : imagen con datos codificados en pixeles</c>
<c>* - FrameCount      : contador de frames</c>
<c>* - Timestamp       : marca de tiempo</c>
<c>* - EncoderPosition : posicion del encoder</c>
<c>* - EncoderIndex    : indice del encoder</c>
<c>* - Inputs          : entradas digitales</c>
<c>* - xOffset         : desplazamiento X en mm</c>
<c>* - yOffset         : desplazamiento Y en mm</c>
<c>* - zOffset         : desplazamiento Z en mm</c>
<c>* - xResolution     : resolucion X en mm</c>
<c>* - yResolution     : resolucion Y en mm</c>
<c>* - zResolution     : resolucion Z en mm</c>
<c>* - Width           : ancho de la medicion</c>
<c>* - Length          : largo de la medicion</c>
<c>* - HasIntensity    : flag si hay canal de intensidad</c>
<c>* - NumScans        : numero total de escaneos disponibles</c>
<c>********************************************************************************</c>
<c></c>
<l>count_channels (Image, channelCount)</l>
<c></c>
<l>if (channelCount = 1)</l>
<c></c>
<c>    * Imagen mono: ultima fila contiene los metadatos</c>
<l>    get_image_size (Image, monoImageWidth, monoImageHeight)</l>
<l>    crop_rectangle1 (Image, Stamps, monoImageHeight - 1, 0, monoImageHeight-1, monoImageWidth)</l>
<c></c>
<c>    * Extraer datos codificados</c>
<l>    Go2GenTLStamp (Stamps, 1, FrameCount)</l>
<l>    Go2GenTLStamp (Stamps, 2, Timestamp)</l>
<l>    Go2GenTLStamp (Stamps, 3, EncoderPosition)</l>
<l>    Go2GenTLStamp (Stamps, 4, EncoderIndex)</l>
<l>    Go2GenTLStamp (Stamps, 5, Inputs)</l>
<l>    Go2GenTLStamp (Stamps, 6, xOffset)</l>
<l>    Go2GenTLStamp (Stamps, 7, xResolution)</l>
<l>    Go2GenTLStamp (Stamps, 8, yOffset)</l>
<l>    Go2GenTLStamp (Stamps, 9, yResolution)</l>
<l>    Go2GenTLStamp (Stamps, 10, zOffset)</l>
<l>    Go2GenTLStamp (Stamps, 11, zResolution)</l>
<l>    Go2GenTLStamp (Stamps, 12, Width)</l>
<l>    Go2GenTLStamp (Stamps, 13, Length)</l>
<l>    Go2GenTLStamp (Stamps, 14, HasIntensity)</l>
<l>    Go2GenTLStamp (Stamps, 15, NumScans)</l>
<c></c>
<c>    * Extraer imagen de altura</c>
<c>    * * Mono output does not support multiple heightmaps, assuming index is 0</c>
<l>    crop_rectangle1 (Image, HeightMap, 0, 0, Length - 1, Width)</l>
<l>    if (HasIntensity = 1)</l>
<c>        * Extraer intensidad de la zona intermedia de la imagen</c>
<l>        IntensityPosition := (monoImageHeight - 1)/2</l>
<l>        crop_rectangle1 (Image, Intensity, IntensityPosition, 0, IntensityPosition + Length - 1, Width)</l>
<l>    else</l>
<c>        * Si no hay intensidad, crear imagen vacia</c>
<l>        gen_image_const (Intensity, 'byte', Width, Length)</l>
<l>    endif</l>
<c></c>
<l>elseif (channelCount = 3)</l>
<c></c>
<c>    * Imagen RGB: separamos altura, intensidad y metadatos</c>
<l>    decompose3 (Image, HeightMap, Intensity, Stamps)</l>
<c></c>
<l>    get_image_size (Image, monoImageWidth, monoImageHeight)</l>
<c></c>
<c>    * Extraer datos codificados</c>
<l>    Go2GenTLStamp (Stamps, 1, FrameCount)</l>
<l>    Go2GenTLStamp (Stamps, 2, Timestamp)</l>
<l>    Go2GenTLStamp (Stamps, 3, EncoderPosition)</l>
<l>    Go2GenTLStamp (Stamps, 4, EncoderIndex)</l>
<l>    Go2GenTLStamp (Stamps, 5, Inputs)</l>
<l>    Go2GenTLStamp (Stamps, 6, xOffset)</l>
<l>    Go2GenTLStamp (Stamps, 7, xResolution)</l>
<l>    Go2GenTLStamp (Stamps, 8, yOffset)</l>
<l>    Go2GenTLStamp (Stamps, 9, yResolution)</l>
<l>    Go2GenTLStamp (Stamps, 10, zOffset)</l>
<l>    Go2GenTLStamp (Stamps, 11, zResolution)</l>
<l>    Go2GenTLStamp (Stamps, 12, Width)</l>
<l>    Go2GenTLStamp (Stamps, 13, Length)</l>
<l>    Go2GenTLStamp (Stamps, 14, HasIntensity)</l>
<l>    Go2GenTLStamp (Stamps, 15, NumScans)</l>
<c></c>
<c>    * Extraer la porcion correspondiente al escaneo indicado</c>
<c>    * * Split Height Map</c>
<l>    start := Index * (Length)</l>
<l>    end := (Index+1) * (Length)</l>
<c></c>
<l>    if (NumScans &gt; Index)</l>
<l>        crop_rectangle1 (HeightMap, HeightMap, start, 0, end, Width)</l>
<l>        if (HasIntensity = 1)</l>
<l>            crop_rectangle1 (Intensity, Intensity, start, 0, end, Width)</l>
<l>        endif</l>
<l>    endif</l>
<c></c>
<l>endif</l>
<c></c>
<c>* Convertir desplazamientos y resoluciones a mm</c>
<c>* * Change Offset and resolution back to floating point and described in mm</c>
<l>xOffset := xOffset / 1000000.0</l>
<l>yOffset := yOffset / 1000000.0</l>
<l>zOffset := zOffset / 1000000.0</l>
<l>xResolution := xResolution / 1000000.0</l>
<l>yResolution := yResolution / 1000000.0</l>
<l>zResolution := zResolution / 1000000.0</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Go2GenTL_ParseData">
<parameters>
<parameter id="EncoderIndex"/>
<parameter id="EncoderPosition"/>
<parameter id="FrameCount"/>
<parameter id="HasIntensity"/>
<parameter id="HeightMap"/>
<parameter id="Image"/>
<parameter id="Index"/>
<parameter id="Inputs"/>
<parameter id="Intensity"/>
<parameter id="Length"/>
<parameter id="NumScans"/>
<parameter id="Timestamp"/>
<parameter id="Width"/>
<parameter id="xOffset"/>
<parameter id="xResolution"/>
<parameter id="yOffset"/>
<parameter id="yResolution"/>
<parameter id="zOffset"/>
<parameter id="zResolution"/>
</parameters>
</docu>
</procedure>
<procedure name="Imagenes_XYZ_heightmap">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="HeightMap" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="X" base_type="iconic" dimension="0"/>
<par name="Y" base_type="iconic" dimension="0"/>
<par name="ZFin" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="xResolution" base_type="ctrl" dimension="0"/>
<par name="xOffset" base_type="ctrl" dimension="0"/>
<par name="yResolution" base_type="ctrl" dimension="0"/>
<par name="yOffset" base_type="ctrl" dimension="0"/>
<par name="zResolution" base_type="ctrl" dimension="0"/>
<par name="zOffset" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* DESCRIPCION :</c>
<c>* Convierte una imagen de altura en coordenadas X, Y, Z reales aplicando</c>
<c>* escala, offset y correcciones basicas. Prepara las imagenes X, Y, Z</c>
<c>* en unidades metricas. Se considera una posible transformacion externa.</c>
<c>*</c>
<c>* ENTRADAS</c>
<c>* - HeightMap            : imagen de altura original</c>
<c>* - xResolution          : resolucion horizontal (X) en mm/pixel</c>
<c>* - yResolution          : resolucion vertical (Y) en mm/pixel</c>
<c>* - zResolution          : resolucion de altura (Z) en mm/pixel</c>
<c>* - xOffset              : offset X en mm</c>
<c>* - yOffset              : offset Y en mm</c>
<c>* - zOffset              : offset Z en mm</c>
<c>*</c>
<c>* SALIDAS</c>
<c>* - X                    : imagen de coordenadas X reales (en metros)</c>
<c>* - Y                    : imagen de coordenadas Y reales (en metros)</c>
<c>* - ZFin                 : imagen Z escalada y corregida (en metros)</c>
<c>********************************************************************************</c>
<c></c>
<c>* Obtener tamaño de imagen</c>
<l>get_image_size (HeightMap, Width2, Height2)</l>
<c></c>
<c>* Generar imagen X con escala y offset correctos [metros]</c>
<l>gen_image_surface_first_order (X, 'real', 0, xResolution * 1, xOffset * 1, 0, 0, Width2, Height2)</l>
<c></c>
<c>* Generar imagen Y con escala y offset correctos [metros]</c>
<l>gen_image_surface_first_order (Y, 'real', yResolution * 1, 0, yOffset * 0, 0, 0, Width2, Height2)</l>
<c></c>
<c>* Create Z</c>
<l>threshold (HeightMap, Region, 1, lsh(1,16) - 1)</l>
<l>reduce_domain (HeightMap, Region, ImageReduced)</l>
<l>convert_image_type (ImageReduced, Z, 'real')</l>
<c></c>
<c>* Inicializar variables de transformacion externas (si se usan)</c>
<l>try</l>
<l>    xOffsetTransform := 0</l>
<l>    zOffsetTransform := 0</l>
<l>    AngleTransform := 0</l>
<l>    OrientationTransform := 0</l>
<l>    StandOff := 0</l>
<c>    * Go2GenTL_Transformation (AcqHandle, xOffsetTransform, zOffsetTransform, AngleTransform, OrientationTransform, StandOff)</c>
<l>catch (Exception)</l>
<c></c>
<l>endtry</l>
<c></c>
<c>* Interpretar desplazamiento Z como entero con signo</c>
<c>* Transformation values in [um]</c>
<c>* The uint4 values have to be interpreted as int4</c>
<l>if (zOffsetTransform &gt; lsh(1,31))</l>
<l>    zOffsetTransform_signed := zOffsetTransform - lsh(1,32)</l>
<l>else</l>
<l>    zOffsetTransform_signed := zOffsetTransform</l>
<l>endif</l>
<c></c>
<c>* Escalar imagen Z a unidades fisicas (metros)</c>
<l>scale_image (Z, ZFin, -zResolution * -1e-0, (StandOff + zOffsetTransform_signed) * 1e-3 + zOffset * 1e-0)</l>
<l>return ()</l>
</body>
<docu id="Imagenes_XYZ_heightmap">
<parameters>
<parameter id="HeightMap"/>
<parameter id="Image"/>
<parameter id="X"/>
<parameter id="Y"/>
<parameter id="ZFin"/>
<parameter id="xOffset"/>
<parameter id="xResolution"/>
<parameter id="yOffset"/>
<parameter id="yResolution"/>
<parameter id="zOffset"/>
<parameter id="zResolution"/>
</parameters>
</docu>
</procedure>
<procedure name="scale_image_range">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageScaled" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Min" base_type="ctrl" dimension="0"/>
<par name="Max" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Convenience procedure to scale the gray values of the</c>
<c>* input image Image from the interval [Min,Max]</c>
<c>* to the interval [0,255] (default).</c>
<c>* Gray values &lt; 0 or &gt; 255 (after scaling) are clipped.</c>
<c>* </c>
<c>* If the image shall be scaled to an interval different from [0,255],</c>
<c>* this can be achieved by passing tuples with 2 values [From, To]</c>
<c>* as Min and Max.</c>
<c>* Example:</c>
<c>* scale_image_range(Image:ImageScaled:[100,50],[200,250])</c>
<c>* maps the gray values of Image from the interval [100,200] to [50,250].</c>
<c>* All other gray values will be clipped.</c>
<c>* </c>
<c>* input parameters:</c>
<c>* Image: the input image</c>
<c>* Min: the minimum gray value which will be mapped to 0</c>
<c>*      If a tuple with two values is given, the first value will</c>
<c>*      be mapped to the second value.</c>
<c>* Max: The maximum gray value which will be mapped to 255</c>
<c>*      If a tuple with two values is given, the first value will</c>
<c>*      be mapped to the second value.</c>
<c>* </c>
<c>* Output parameter:</c>
<c>* ImageScale: the resulting scaled image.</c>
<c>* </c>
<l>if (|Min| == 2)</l>
<l>    LowerLimit := Min[1]</l>
<l>    Min := Min[0]</l>
<l>else</l>
<l>    LowerLimit := 0.0</l>
<l>endif</l>
<l>if (|Max| == 2)</l>
<l>    UpperLimit := Max[1]</l>
<l>    Max := Max[0]</l>
<l>else</l>
<l>    UpperLimit := 255.0</l>
<l>endif</l>
<c>* </c>
<c>* Calculate scaling parameters.</c>
<c>* Only scale if the scaling range is not zero.</c>
<l>if (not (abs(Max - Min) &lt; 1.0E-6))</l>
<l>    Mult := real(UpperLimit - LowerLimit) / (Max - Min)</l>
<l>    Add := -Mult * Min + LowerLimit</l>
<c>    * Scale image.</c>
<l>    scale_image (Image, Image, Mult, Add)</l>
<l>endif</l>
<c>* </c>
<c>* Clip gray values if necessary.</c>
<c>* This must be done for each image and channel separately.</c>
<l>gen_empty_obj (ImageScaled)</l>
<l>count_obj (Image, NumImages)</l>
<l>for ImageIndex := 1 to NumImages by 1</l>
<l>    select_obj (Image, ImageSelected, ImageIndex)</l>
<l>    count_channels (ImageSelected, Channels)</l>
<l>    for ChannelIndex := 1 to Channels by 1</l>
<l>        access_channel (ImageSelected, SelectedChannel, ChannelIndex)</l>
<l>        min_max_gray (SelectedChannel, SelectedChannel, 0, MinGray, MaxGray, Range)</l>
<l>        threshold (SelectedChannel, LowerRegion, min([MinGray,LowerLimit]), LowerLimit)</l>
<l>        threshold (SelectedChannel, UpperRegion, UpperLimit, max([UpperLimit,MaxGray]))</l>
<l>        paint_region (LowerRegion, SelectedChannel, SelectedChannel, LowerLimit, 'fill')</l>
<l>        paint_region (UpperRegion, SelectedChannel, SelectedChannel, UpperLimit, 'fill')</l>
<l>        if (ChannelIndex == 1)</l>
<l>            copy_obj (SelectedChannel, ImageSelectedScaled, 1, 1)</l>
<l>        else</l>
<l>            append_channel (ImageSelectedScaled, SelectedChannel, ImageSelectedScaled)</l>
<l>        endif</l>
<l>    endfor</l>
<l>    concat_obj (ImageScaled, ImageSelectedScaled, ImageScaled)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="scale_image_range">
<abstract lang="en_US">Convenience procedure to scale the gray values of the input image Image from the interval [Min,Max] to the interval [*0*,*255*] (default).
Gray values &lt; *0* or &gt; *255* (after scaling) are clipped.
If the image shall be scaled to an interval different from [*0*,*255*], this can be achieved by passing tuples with 2 values [*From*, *To*] as Min and Max.

Example:

      scale_image_range (Image, ImageScaled, [100,50], [200,250])
maps the gray values of Image from the interval [*100*,*200*] to [*50*,*250*].
All other gray values will be clipped.</abstract>
<alternatives>
<item>scale_image</item>
<item>scale_image_max</item>
</alternatives>
<chapters lang="de_DE">
<item>Filter</item>
<item>Arithmetik</item>
</chapters>
<chapters lang="en_US">
<item>Filters</item>
<item>Arithmetic</item>
</chapters>
<chapters lang="ja_JP">
<item>フィルター</item>
<item>算術</item>
</chapters>
<example lang="en_US">read_image (Image, 'fabrik')
scale_image_range (Image, ImageScaled, [100,50], [200,250])</example>
<keywords lang="de_DE">
<item>Grauwerte skalieren</item>
</keywords>
<keywords lang="en_US">
<item>scale gray values</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>scale_image</item>
<item>scale_image_max</item>
</see_also>
<short>Scale the gray values of an image from the interval [Min,Max] to [0,255]</short>
<short lang="en_US">Scale the gray values of an image from the interval [Min,Max] to [0,255]</short>
<parameters>
<parameter id="Image">
<description lang="en_US">The input image to be scaled</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
</type_list>
</parameter>
<parameter id="ImageScaled">
<description lang="en_US">The scaled output image</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
</type_list>
</parameter>
<parameter id="Max">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The maximum gray value which will be mapped to 255. If a tuple with two values is given, the first value will be mapped to the second value.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Min">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The minimum gray value which will be mapped to 0. If a tuple with two values is given, the first value will be mapped to the second value.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="set_display_font">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Size" base_type="ctrl" dimension="0"/>
<par name="Font" base_type="ctrl" dimension="0"/>
<par name="Bold" base_type="ctrl" dimension="0"/>
<par name="Slant" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure sets the text font of the current window with</c>
<c>* the specified attributes.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The graphics window for which the font will be set</c>
<c>* Size: The font size. If Size=-1, the default of 16 is used.</c>
<c>* Bold: If set to 'true', a bold font is used</c>
<c>* Slant: If set to 'true', a slanted font is used</c>
<c>* </c>
<l>get_system ('operating_system', OS)</l>
<l>if (Size == [] or Size == -1)</l>
<l>    Size := 16</l>
<l>endif</l>
<l>if (OS{0:2} == 'Win')</l>
<c>    * Restore previous behavior</c>
<l>    Size := int(1.13677 * Size)</l>
<l>else</l>
<l>    Size := int(Size)</l>
<l>endif</l>
<l>if (Font == 'Courier')</l>
<l>    Fonts := ['Courier', 'Courier 10 Pitch', 'Courier New', 'CourierNew', 'Liberation Mono']</l>
<l>elseif (Font == 'mono')</l>
<l>    Fonts := ['Consolas', 'Menlo', 'Courier', 'Courier 10 Pitch', 'FreeMono', 'Liberation Mono', 'DejaVu Sans Mono']</l>
<l>elseif (Font == 'sans')</l>
<l>    Fonts := ['Luxi Sans', 'DejaVu Sans', 'FreeSans', 'Arial', 'Liberation Sans']</l>
<l>elseif (Font == 'serif')</l>
<l>    Fonts := ['Times New Roman', 'Luxi Serif', 'DejaVu Serif', 'FreeSerif', 'Utopia', 'Liberation Serif']</l>
<l>else</l>
<l>    Fonts := Font</l>
<l>endif</l>
<l>Style := ''</l>
<l>if (Bold == 'true')</l>
<l>    Style := Style + 'Bold'</l>
<l>elseif (Bold != 'false')</l>
<l>    Exception := 'Wrong value of control parameter Bold'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<l>if (Slant == 'true')</l>
<l>    Style := Style + 'Italic'</l>
<l>elseif (Slant != 'false')</l>
<l>    Exception := 'Wrong value of control parameter Slant'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<l>if (Style == '')</l>
<l>    Style := 'Normal'</l>
<l>endif</l>
<l>query_font (WindowHandle, AvailableFonts)</l>
<l>Font := ''</l>
<l>for Fdx := 0 to |Fonts| - 1 by 1</l>
<l>    Indices := find(AvailableFonts,Fonts[Fdx])</l>
<l>    if (|Indices| &gt; 0)</l>
<l>        if (Indices[0] &gt;= 0)</l>
<l>            Font := Fonts[Fdx]</l>
<l>            break</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>if (Font == '')</l>
<l>    throw ('Wrong value of control parameter Font')</l>
<l>endif</l>
<l>Font := Font + '-' + Style + '-' + Size</l>
<l>set_font (WindowHandle, Font)</l>
<l>return ()</l>
</body>
<docu id="set_display_font">
<abstract lang="en_US">This procedure sets the text font of the current window with the specified attributes Size, Bold and Slant. 
As font, the font name or one of the strings *'mono'*, *'sans'*, *'serif'* can be used.</abstract>
<alternatives>
<item>set_font</item>
</alternatives>
<attention lang="en_US">For *'mono'*, *'sans'*, and *'serif'*, it is assumed that at least one of the following fonts is installed on the system:

*'mono'*: 'Consolas'*, *'Menlo'*, *'Courier'*, *'Courier 10 Pitch'*, *'FreeMono'*\
*'sans'*: *'Luxi Sans'*, *'DejaVu Sans'*, *'FreeSans'*, *'Arial'*\
*'serif'*: *'Times New Roman'*, *'Luxi Serif'*, *'DejaVu Serif'*, *'FreeSerif'*, *'Utopia'*</attention>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="ja_JP">
<item>グラフィック</item>
<item>テキスト</item>
</chapters>
<example lang="en_US">dev_open_window_fit_image(Image,0 , 0, 400, 400, WindowHandle)
set_display_font(WindowHandle, 16, 'mono', 'true', 'false')
disp_text (WindowHandle,'Hello World!', 'window', 10, 10, 'black', [], [])</example>
<keywords lang="de_DE">
<item>Schriftart (Font) setzen</item>
</keywords>
<keywords lang="en_US">
<item>set font</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
<item>open_window</item>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
</predecessor>
<see_also>
<item>set_font</item>
</see_also>
<short>Set font independent of OS</short>
<short lang="en_US">Set font independent of OS</short>
<successor>
<item>disp_text</item>
<item>disp_continue_message</item>
<item>set_tposition</item>
<item>write_string</item>
</successor>
<parameters>
<parameter id="Bold">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', a bold font is used</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="Font">
<default_type>string</default_type>
<default_value>'mono'</default_value>
<description lang="en_US">The font name. Either 'mono', 'sans',  'serif' or a specific font name can be used. 'mono' will be mapped to 'Courier New' on Windows and to 'courier' on Linux. 'sans' will be mapped to 'Arial' on Windows and to 'helvetica' on Linux. 'serif' will be mapped to 'Times New Roman' on Windows and to 'times' on Linux.</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'mono'</item>
<item>'sans'</item>
<item>'serif'</item>
</values>
</parameter>
<parameter id="Size">
<default_type>integer</default_type>
<default_value>16</default_value>
<description lang="en_US">The font size on Windows systems. If Size=-1, the default of 16 is used.
On Linux systems, ALL values are multiplied with 1.25 and then mapped to [11, 14, 17, 20, 25, 34].</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>[9, 11, 14, 16, 20, 27]</item>
</values>
</parameter>
<parameter id="Slant">
<default_type>string</default_type>
<default_value>'false'</default_value>
<description lang="en_US">If set to 'true', a slanted font is used</description>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the window, where the font will be set</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="Go2GenTLStamp">
<interface>
<io>
<par name="Stamps" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Index" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Value" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION :</c>
<c>* Extrae y reconstruye un valor numerico codificado en una imagen de</c>
<c>* tipo sello, proveniente de un sensor Gocator. El valor se compone de</c>
<c>* 4 componentes (cada uno de 16 bits). Se adapta el resultado segun si</c>
<c>* se esta ejecutando en un sistema de 64 o 32 bits.</c>
<c>*</c>
<c>* ENTRADAS</c>
<c>* - Stamps       : imagen que contiene los valores codificados</c>
<c>* - Index        : posicion del valor a leer (en bloques de 4 bytes)</c>
<c>*</c>
<c>* SALIDAS</c>
<c>* - Value        : valor reconstruido (entero, 32 o 64 bits segun sistema)</c>
<c>********************************************************************************</c>
<c></c>
<c>* Check if we are on a 64-bit machine</c>
<l>test_value := 0xFFFFFFFF</l>
<l>if (test_value &gt; 0)</l>
<l>    is64bit := 1</l>
<l>else</l>
<l>    is64bit := 0</l>
<l>endif</l>
<c></c>
<c>* Leer 4 valores de 16 bits desde la imagen</c>
<l>get_grayval (Stamps, 0, (Index * 4), tempvalue0)</l>
<l>get_grayval (Stamps, 0, (Index * 4) + 1, tempvalue1)</l>
<l>get_grayval (Stamps, 0, (Index * 4) + 2, tempvalue2)</l>
<l>get_grayval (Stamps, 0, (Index * 4) + 3, tempvalue3)</l>
<c></c>
<c>* The actual stamp from the Gocator is 64-bit. tempvalue0 is the most significant 16-bit (i.e. the top bit is the sign bit)</c>
<c>* The code below assumes we only need the bottom 32-bit information. User need to update this conversion function if they want to</c>
<c>* return 64-bit value.</c>
<c></c>
<l>if (is64bit = 1)</l>
<l>    tuple_lsh (tempvalue0, 48, tempvalue0)</l>
<l>    tuple_lsh (tempvalue1, 32, tempvalue1)</l>
<l>    tuple_lsh (tempvalue2, 16, tempvalue2)</l>
<l>    tuple_lsh (tempvalue3, 0, tempvalue3)</l>
<l>    Value := tempvalue0 + tempvalue1 + tempvalue2 + tempvalue3</l>
<l>else</l>
<l>    tuple_lsh (tempvalue2, 16, tempvalue2)</l>
<l>    tuple_lsh (tempvalue3, 0, tempvalue3)</l>
<l>    Value := tempvalue2 + tempvalue3</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="Go2GenTLStamp">
<parameters>
<parameter id="Index"/>
<parameter id="Stamps"/>
<parameter id="Value"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_arrow_contour_xld">
<interface>
<oo>
<par name="Arrow" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="HeadLength" base_type="ctrl" dimension="0"/>
<par name="HeadWidth" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure generates arrow shaped XLD contours,</c>
<c>* pointing from (Row1, Column1) to (Row2, Column2).</c>
<c>* If starting and end point are identical, a contour consisting</c>
<c>* of a single point is returned.</c>
<c>* </c>
<c>* input parameters:</c>
<c>* Row1, Column1: Coordinates of the arrows' starting points</c>
<c>* Row2, Column2: Coordinates of the arrows' end points</c>
<c>* HeadLength, HeadWidth: Size of the arrow heads in pixels</c>
<c>* </c>
<c>* output parameter:</c>
<c>* Arrow: The resulting XLD contour</c>
<c>* </c>
<c>* The input tuples Row1, Column1, Row2, and Column2 have to be of</c>
<c>* the same length.</c>
<c>* HeadLength and HeadWidth either have to be of the same length as</c>
<c>* Row1, Column1, Row2, and Column2 or have to be a single element.</c>
<c>* If one of the above restrictions is violated, an error will occur.</c>
<c>* </c>
<c>* </c>
<c>* Initialization.</c>
<l>gen_empty_obj (Arrow)</l>
<c>* </c>
<c>* Calculate the arrow length</c>
<l>distance_pp (Row1, Column1, Row2, Column2, Length)</l>
<c>* </c>
<c>* Mark arrows with identical start and end point</c>
<c>* (set Length to -1 to avoid division-by-zero exception)</c>
<l>ZeroLengthIndices := find(Length,0)</l>
<l>if (ZeroLengthIndices != -1)</l>
<l>    Length[ZeroLengthIndices] := -1</l>
<l>endif</l>
<c>* </c>
<c>* Calculate auxiliary variables.</c>
<l>DR := 1.0 * (Row2 - Row1) / Length</l>
<l>DC := 1.0 * (Column2 - Column1) / Length</l>
<l>HalfHeadWidth := HeadWidth / 2.0</l>
<c>* </c>
<c>* Calculate end points of the arrow head.</c>
<l>RowP1 := Row1 + (Length - HeadLength) * DR + HalfHeadWidth * DC</l>
<l>ColP1 := Column1 + (Length - HeadLength) * DC - HalfHeadWidth * DR</l>
<l>RowP2 := Row1 + (Length - HeadLength) * DR - HalfHeadWidth * DC</l>
<l>ColP2 := Column1 + (Length - HeadLength) * DC + HalfHeadWidth * DR</l>
<c>* </c>
<c>* Finally create output XLD contour for each input point pair</c>
<l>for Index := 0 to |Length| - 1 by 1</l>
<l>    if (Length[Index] == -1)</l>
<c>        * Create_ single points for arrows with identical start and end point</c>
<l>        gen_contour_polygon_xld (TempArrow, Row1[Index], Column1[Index])</l>
<l>    else</l>
<c>        * Create arrow contour</c>
<l>        gen_contour_polygon_xld (TempArrow, [Row1[Index],Row2[Index],RowP1[Index],Row2[Index],RowP2[Index],Row2[Index]], [Column1[Index],Column2[Index],ColP1[Index],Column2[Index],ColP2[Index],Column2[Index]])</l>
<l>    endif</l>
<l>    concat_obj (Arrow, TempArrow, Arrow)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_arrow_contour_xld">
<abstract lang="en_US">This procedure creates arrow shaped XLD contours, which point from the coordinates (Row1, Column1) to the coordinates (Row2, Column2). The shape of the arrow head can be specified with the parameters HeadLength and HeadWidth (in pixels).

If starting and end point are identical, a contour consisting of a single point is returned.

The input tuples Row1, Column1, Row2, and Column2 have to be of the same length. HeadLength and HeadWidth either have to be of the same length as Row1, Column1, Row2, and Column2 or have to be a single element. If one of the above restrictions is violated, an error will occur.</abstract>
<alternatives>
<item>disp_arrow</item>
<item>gen_contour_polygon_xld</item>
</alternatives>
<chapters lang="de_DE">
<item>XLD</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>XLD</item>
<item>Creation</item>
</chapters>
<chapters lang="ja_JP">
<item>XLD</item>
<item>生成</item>
</chapters>
<example lang="en_US">StartPointRows:=[100,100]
StartPointColumns:=[100,100]
EndPointRows:=[200,50]
EndPointColumns:=[200,150]
dev_set_colored (3)
gen_arrow_contour_xld (Arrow, StartPointRows, StartPointColumns, EndPointRows, EndPointColumns, [10,20], [20,10])</example>
<keywords lang="de_DE">
<item>XLD-Konturen erzeugen</item>
<item>XLD-Kontur eines Pfeils erzeugen</item>
</keywords>
<keywords lang="en_US">
<item>create XLD contours</item>
<item>create XLD contour of arrow</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>gen_contour_nurbs_xld</item>
</see_also>
<short lang="en_US">Create an arrow shaped XLD contour.</short>
<successor>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="Arrow">
<description lang="en_US">The generated xld</description>
<multivalue>optional</multivalue>
<sem_type>xld_cont</sem_type>
</parameter>
<parameter id="Column1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The column coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The column coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HeadLength">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The length of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="HeadWidth">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The width of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="Row1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The row coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Row2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The row coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="list_image_files">
<interface>
<ic>
<par name="ImageDirectory" base_type="ctrl" dimension="0"/>
<par name="Extensions" base_type="ctrl" dimension="0"/>
<par name="Options" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure returns all files in a given directory</c>
<c>* with one of the suffixes specified in Extensions.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* ImageDirectory: Directory or a tuple of directories with images.</c>
<c>*    If a directory is not found locally, the respective directory</c>
<c>*    is searched under %HALCONIMAGES%/ImageDirectory.</c>
<c>*    See the Installation Guide for further information</c>
<c>*    in case %HALCONIMAGES% is not set.</c>
<c>* Extensions: A string tuple containing the extensions to be found</c>
<c>*    e.g. ['png','tif',jpg'] or others</c>
<c>* If Extensions is set to 'default' or the empty string '',</c>
<c>*    all image suffixes supported by HALCON are used.</c>
<c>* Options: as in the operator list_files, except that the 'files'</c>
<c>*    option is always used. Note that the 'directories' option</c>
<c>*    has no effect but increases runtime, because only files are</c>
<c>*    returned.</c>
<c>* </c>
<c>* Output parameter:</c>
<c>* ImageFiles: A tuple of all found image file names</c>
<c>* </c>
<l>if (Extensions == [] or Extensions == '' or Extensions == 'default')</l>
<l>    Extensions := ['ima', 'tif', 'tiff', 'gif', 'bmp', 'jpg', 'jpeg', 'jp2', 'jxr', 'png', 'pcx', 'ras', 'xwd', 'pbm', 'pnm', 'pgm', 'ppm']</l>
<c>    * </c>
<l>endif</l>
<l>ImageFiles := []</l>
<c>* Loop through all given image directories.</c>
<l>for ImageDirectoryIndex := 0 to |ImageDirectory| - 1 by 1</l>
<l>    ImageFilesTmp := []</l>
<l>    CurrentImageDirectory := ImageDirectory[ImageDirectoryIndex]</l>
<l>    if (CurrentImageDirectory == '')</l>
<l>        CurrentImageDirectory := '.'</l>
<l>    endif</l>
<l>    get_system ('image_dir', HalconImages)</l>
<l>    get_system ('operating_system', OS)</l>
<l>    if (OS{0:2} == 'Win')</l>
<l>        HalconImages := split(HalconImages,';')</l>
<l>    else</l>
<l>        HalconImages := split(HalconImages,':')</l>
<l>    endif</l>
<l>    Directories := CurrentImageDirectory</l>
<l>    for Index := 0 to |HalconImages| - 1 by 1</l>
<l>        Directories := [Directories,HalconImages[Index] + '/' + CurrentImageDirectory]</l>
<l>    endfor</l>
<l>    tuple_strlen (Directories, Length)</l>
<l>    tuple_gen_const (|Length|, false, NetworkDrive)</l>
<l>    if (OS{0:2} == 'Win')</l>
<l>        for Index := 0 to |Length| - 1 by 1</l>
<l>            if (strlen(Directories[Index]) &gt; 1)</l>
<l>                tuple_str_first_n (Directories[Index], 1, Substring)</l>
<l>                if (Substring == '//' or Substring == '\\\\')</l>
<l>                    NetworkDrive[Index] := true</l>
<l>                endif</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>    ImageFilesTmp := []</l>
<l>    for Index := 0 to |Directories| - 1 by 1</l>
<l>        file_exists (Directories[Index], FileExists)</l>
<l>        if (FileExists)</l>
<l>            list_files (Directories[Index], ['files',Options], AllFiles)</l>
<l>            ImageFilesTmp := []</l>
<l>            for i := 0 to |Extensions| - 1 by 1</l>
<l>                tuple_regexp_select (AllFiles, ['.*' + Extensions[i] + '$','ignore_case'], Selection)</l>
<l>                ImageFilesTmp := [ImageFilesTmp,Selection]</l>
<l>            endfor</l>
<l>            tuple_regexp_replace (ImageFilesTmp, ['\\\\', 'replace_all'], '/', ImageFilesTmp)</l>
<l>            if (NetworkDrive[Index])</l>
<l>                tuple_regexp_replace (ImageFilesTmp, ['//', 'replace_all'], '/', ImageFilesTmp)</l>
<l>                ImageFilesTmp := '/' + ImageFilesTmp</l>
<l>            else</l>
<l>                tuple_regexp_replace (ImageFilesTmp, ['//', 'replace_all'], '/', ImageFilesTmp)</l>
<l>            endif</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Concatenate the output image paths.</c>
<l>    ImageFiles := [ImageFiles,ImageFilesTmp]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="list_image_files">
<abstract lang="en_US">This procedure returns all files in a given directory ImageDirectory with one of the suffixes specified in Extensions.

It is possible to use a tuple with multiple directories as input ImageDirectory. If a directory is not found locally, the respective directory is searched under %HALCONIMAGES%/ImageDirectory. See the `Installation Guide` for further information in case %HALCONIMAGES% is not set.

If Extensions is set to *'default'* or the empty string *''*, all image suffixes supported by HALCON are used.

The parameter Options is used as in the operator &lt;op:list_files&gt; (see &lt;op:list_files&gt; for details), except that the *'files'* option is always used. Note that the *'directories'* option has no effect but increases runtime, because only files are returned.</abstract>
<alternatives>
<item>list_files</item>
</alternatives>
<chapters lang="de_DE">
<item>Datei</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>File</item>
<item>Misc</item>
</chapters>
<chapters lang="ja_JP">
<item>ファイル</item>
<item>その他</item>
</chapters>
<example lang="en_US">list_image_files ('.',[] ,[] , ImageFiles)
for Index := 1 to |ImageFiles|  by 1
    read_image (Image,ImageFiles[Index-1])
*     do something
endfor</example>
<keywords lang="de_DE">
<item>Bilddateien auflisten</item>
</keywords>
<keywords lang="en_US">
<item>list image files</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>list_files</item>
</predecessor>
<see_also>
<item>list_files</item>
</see_also>
<short>Get all image files under the given path</short>
<short lang="en_US">Get all image files under the given path</short>
<successor>
<item>read_image</item>
</successor>
<parameters>
<parameter id="Extensions">
<default_type>string</default_type>
<default_value>'default'</default_value>
<description lang="en_US">A string tuple containing the extensions to be found e.g. ['png','tif',jpg'] or others</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'ima'</item>
<item>'bmp'</item>
<item>'jpg'</item>
<item>'png'</item>
<item>'tiff'</item>
<item>'tif'</item>
<item>'gif'</item>
<item>'jpeg'</item>
<item>'pcx'</item>
<item>'pgm'</item>
<item>'ppm'</item>
<item>'pbm'</item>
<item>'xwd'</item>
<item>'pnm'</item>
</values>
</parameter>
<parameter id="ImageDirectory">
<default_type>string</default_type>
<description lang="en_US">The image directory</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="en_US">A tuple of all found image file names</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.read</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Options">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Processing options</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'recursive'</item>
<item>'follow_links'</item>
<item>'max_depth 5'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_exception">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Exception" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Muestra en pantalla los distintos campos asociados a una excepcion HDevelop.</c>
<c>* Extrae y visualiza el codigo de error, mensajes, nombre del procedimiento,</c>
<c>* linea de programa, profundidad de pila y el operador implicado.</c>
<c></c>
<c>* ENTRADAS (control):</c>
<c>* - Exception        : excepcion capturada en un bloque try-catch</c>
<c>* - WindowHandle     : handle de la ventana de visualizacion</c>
<c>********************************************************************************</c>
<c></c>
<l>dev_clear_window ()</l>
<l>salto_linea:=60</l>
<l>set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<c></c>
<c>* error_code: Código de error de HALCON o definido por el usuario.</c>
<l>dev_get_exception_data (Exception, 'error_code',error_code)</l>
<l>dev_disp_text ('Codigo de excepcion: ' + error_code, 'window', 0, 'left', 'black', [], [])</l>
<c></c>
<c>* add_error_code: Código de error adicional específico de HDevelop.</c>
<l>dev_get_exception_data (Exception, 'add_error_code', add_error_code)</l>
<l>dev_disp_text ('Codigo adicional: ' + add_error_code, 'window', salto_linea, 'left', 'black', [], [])</l>
<c></c>
<c>* error_message: Mensaje de error de HALCON.</c>
<l>dev_get_exception_data (Exception, 'error_message', error_message)</l>
<l>dev_disp_text ('Msg: ' + error_message, 'window', salto_linea*2, 'left', 'black', [], [])</l>
<c></c>
<c>* add_error_message: Mensaje adicional que describe el error específico de HDevelop.</c>
<l>dev_get_exception_data (Exception, 'add_error_message', add_error_message)</l>
<l>dev_disp_text ('Msg2: ' +add_error_message, 'window', salto_linea*3, 'left', 'black', [], [])</l>
<c></c>
<c>* call_stack_depth: Profundidad de la pila de llamadas.</c>
<l>dev_get_exception_data (Exception, 'call_stack_depth', call_stack_depth)</l>
<l>dev_disp_text ('Profundidad de pila llamada: ' + call_stack_depth, 'window', salto_linea*4, 'left', 'black', [], [])</l>
<c></c>
<c>* procedure: Nombre del procedimiento donde ocurrió el error.</c>
<l>dev_get_exception_data (Exception, 'procedure', procedure)</l>
<l>dev_disp_text ('Procedimiento: ' + procedure, 'window', salto_linea*5, 'left', 'black', [], [])</l>
<c></c>
<c>* program_line: Número de la línea de programa donde ocurrió el error.</c>
<l>dev_get_exception_data (Exception, 'program_line', program_line)</l>
<l>dev_disp_text ('Linea:' + program_line, 'window', salto_linea*6, 'left', 'black', [], [])</l>
<c></c>
<c>* operator: Nombre del operador que lanzó la excepción.</c>
<l>dev_get_exception_data (Exception, 'operator', operator)</l>
<l>dev_disp_text ('Operador: ' + operator, 'window', salto_linea*7, 'left', 'black', [], [])</l>
<c></c>
<l>return ()</l>
</body>
<docu id="dev_display_exception">
<parameters>
<parameter id="Exception"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="tuple_deg2">
<interface>
<ic>
<par name="Rad" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Deg" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Convierte un angulo en radianes a grados euler ajustado a los cuadrantes 3 y 4.</c>
<c>* La salida se fuerza a valores negativos para mantener coherencia con</c>
<c>* el sentido de avance de la cinta transportadora.</c>
<c></c>
<c>* ENTRADAS (control):</c>
<c>* - Rad : angulo en radianes</c>
<c></c>
<c>* SALIDAS (control):</c>
<c>* - Deg : angulo en grados ajustado al 3º y 4º cuadrante</c>
<c>********************************************************************************</c>
<c></c>
<c>* Conversion de radianes a grados</c>
<l>tuple_deg (Rad, Deg)</l>
<c></c>
<c>* Direccion de avance cuadrante 3  y 4</c>
<c>* Ajuste: forzar a valores negativos si es positivo</c>
<l>if (Deg&gt;0)</l>
<l>    Deg:=Deg-180   </l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="tuple_deg2">
<parameters>
<parameter id="Deg"/>
<parameter id="Rad"/>
</parameters>
</docu>
</procedure>
<procedure name="Medicion_Z">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="Espesor_Minimo" base_type="ctrl" dimension="0"/>
<par name="Espesor_Maximo" base_type="ctrl" dimension="0"/>
<par name="Espesor_Medio" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Evalua el espesor de una pieza a partir de una imagen de altura (ZRed).</c>
<c>* Calcula tres regiones segmentadas segun el espesor: bajo, medio y alto.</c>
<c>* Tambien extrae estadisticos min, max y media en la zona central util.</c>
<c>*</c>
<c>* ENTRADAS (icono):</c>
<c>* -Region         : region de interes donde se evaluara el espesor</c>
<c>* -Image          : imagen de altura o profundidad (ZRed)</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* -Espesor_Minimo : valor minimo del espesor en la zona util</c>
<c>* -Espesor_Maximo : valor maximo del espesor en la zona util</c>
<c>* -Espesor_Medio  : valor medio del espesor en la zona util</c>
<c>* -Codigo_Error   : reserva</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<l>if (false)</l>
<l>    dev_clear_window ()</l>
<l>    dev_display (Image)</l>
<l>    dev_display (Region)</l>
<l>endif</l>
<c></c>
<c>* Eliminar pixeles sin datos</c>
<l>threshold (Image, Region1, -10, -0.001)</l>
<l>threshold (Image, Region2, 0.001, 20)</l>
<l>union2 (Region1, Region2, Region)</l>
<c></c>
<c>* Erosionar la region para centrarse en la zona interior</c>
<l>erosion_rectangle1 (Region, RegionErosion, 30,30)    </l>
<c></c>
<c>* Reducir imagen original a la zona erosionada</c>
<l>reduce_domain (Image, RegionErosion, ImageRed)</l>
<c></c>
<c>* Calcular estadisticos de espesor</c>
<l>gray_features (RegionErosion, Image, 'min', Espesor_Minimo)</l>
<l>gray_features (RegionErosion, Image, 'max', Espesor_Maximo)</l>
<l>gray_features (RegionErosion, Image, 'mean', Espesor_Medio)</l>
<c></c>
<c>* Debug: detectar pixeles con valores en un rango especifico</c>
<l>if (false)</l>
<l>    gen_empty_obj(RegionZero)</l>
<l>    counter:=0</l>
<l>    get_region_points (RegionErosion, Rows, Cols)</l>
<l>    for I := 0 to |Rows|-1 by 1</l>
<l>        get_grayval(ImageRed, Rows[I], Cols[I], Value)</l>
<l>        if (-2 &lt; Value and Value &lt; 2)</l>
<l>            gen_region_points(Point, Rows[I],Cols[I])</l>
<l>            concat_obj(RegionZero, Point, RegionZero)</l>
<l>            counter:=counter+1</l>
<l>        endif</l>
<l>    endfor</l>
<c>    </c>
<l>    dev_set_color ('green')</l>
<l>    dev_display (RegionZero)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Medicion_Z">
<parameters>
<parameter id="Codigo_Error"/>
<parameter id="Espesor_Maximo"/>
<parameter id="Espesor_Medio"/>
<parameter id="Espesor_Minimo"/>
<parameter id="Image"/>
<parameter id="Region"/>
</parameters>
</docu>
</procedure>
<procedure name="Control_Espesor">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Region_Esp_OK" base_type="iconic" dimension="0"/>
<par name="Region_Esp_Inf" base_type="iconic" dimension="0"/>
<par name="Region_Esp_Sup" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Dict_Var_Prod" base_type="ctrl" dimension="0"/>
<par name="Espesor_Nominal" base_type="ctrl" dimension="0"/>
<par name="Espesor_Minimo" base_type="ctrl" dimension="0"/>
<par name="Espesor_Maximo" base_type="ctrl" dimension="0"/>
<par name="Espesor_Medio" base_type="ctrl" dimension="0"/>
<par name="Umbral_Esp_Medio" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="per_OK" base_type="ctrl" dimension="0"/>
<par name="Valores_MinMax" base_type="ctrl" dimension="0"/>
<par name="Calidad" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Clasifica una region en funcion de su espesor medio comparado con</c>
<c>* los umbrales definidos por tipo. Se calculan porcentajes de area</c>
<c>* para clasificar en 1ª o 2ª clase o descartar.</c>
<c>*</c>
<c>* ENTRADAS (icono):</c>
<c>* -Region            : region binaria de evaluacion</c>
<c>* -Image             : imagen de profundidad o espesor</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* -Dict_Var_Prod     : diccionaro con variables de produccion</c>
<c>* -Espesor_Nominal   : espesor nominal</c>
<c>* -Espesor_Minimo    : valor minimo observado</c>
<c>* -Espesor_Maximo    : valor maximo observado</c>
<c>* -Espesor_Medio     : valor medio observado</c>
<c>* -Umbral_Esp_Medio  : porcentaje minimo del area OK para clasificar</c>
<c>*</c>
<c>* SALIDAS (icono):</c>
<c>* -Region_Esp_OK     : region con espesor dentro del rango principal</c>
<c>* -Region_Esp_Inf    : region con espesor por debajo del minimo</c>
<c>* -Region_Esp_Sup    : region con espesor por encima del maximo</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* -per_OK     : porcentaje del area clasificada como OK</c>
<c>* -Valores_MinMax    : tupla de valores min/max usados segun tipo</c>
<c>* -Calidad           : 1 = primera, 2 = segunda, -1 = descarte</c>
<c>* -Codigo_Error      : 0 = OK</c>
<c>*                      112 = no cumple espesor minimo </c>
<c>*                      113 = no cumple espesor medio</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<c>* Descarte por defecto</c>
<l>Calidad := -1</l>
<l>per_OK := -1</l>
<c></c>
<c>* El espesor minimo no debe ser inferior a 2mm</c>
<l>if (Espesor_Minimo&gt;=2)    </l>
<c>    </c>
<c>    * Extraer valores minimos y maximos de calidad 1 y 2 </c>
<l>    if (Espesor_Nominal==3.5)</l>
<l>        get_dict_tuple (Dict_Var_Prod,'Espesor_3.5',Valores_MinMax)                </l>
<l>    elseif (Espesor_Nominal==4.2)        </l>
<l>        get_dict_tuple (Dict_Var_Prod,'Espesor_4.2',Valores_MinMax)                </l>
<l>    elseif (Espesor_Nominal==5.0)        </l>
<l>        get_dict_tuple (Dict_Var_Prod,'Espesor_5.0',Valores_MinMax)                </l>
<l>    elseif (Espesor_Nominal==7.0)        </l>
<l>        get_dict_tuple (Dict_Var_Prod,'Espesor_7.0',Valores_MinMax)        </l>
<l>    else</l>
<l>        throw (['Espesor no contemplado'])</l>
<l>    endif        </l>
<c>        </c>
<c>    * Region total: calculo de area total aplicacion de valores umbral</c>
<l>    threshold (Image, RegionTotal, 0, 255)</l>
<l>    region_features (RegionTotal, 'area', AreaTotal)</l>
<c>        </c>
<c>    ***** ### COMPROBACION DE CALIDADES POR ESPESOR ### *****       </c>
<l>    for Index := 1 to 2 by 1</l>
<c>        </c>
<c>        * Se asignan los valores maximo y minimo segun calidad</c>
<l>        switch (Index)</l>
<l>        case 1:</l>
<l>            Minimo:=Valores_MinMax[0]</l>
<l>            Maximo:=Valores_MinMax[1]</l>
<c>            </c>
<l>            break</l>
<l>        case 2:</l>
<l>            Minimo:=Valores_MinMax[2]</l>
<l>            Maximo:=Valores_MinMax[3]</l>
<c>                        </c>
<l>            break</l>
<l>        default:</l>
<l>            throw (['Calidad no contemplada'])</l>
<l>        endswitch</l>
<c>        </c>
<c>        * Region OK</c>
<l>        threshold (Image,Region_Esp_OK, Minimo, Maximo)</l>
<c>        </c>
<c>        * Region por debajo del minimo</c>
<l>        threshold (Image,Region_Esp_Inf,-10, Minimo)</l>
<c>        </c>
<c>        * Region por encima del maximo</c>
<l>        threshold (Image,Region_Esp_Sup, Maximo,20)   </l>
<c>        </c>
<c>        * Area de cada region para aplicacion de valores umbral</c>
<l>        region_features (Region_Esp_OK, 'area', Area_OK)</l>
<l>        region_features (Region_Esp_Inf, 'area', Area_Inf)</l>
<l>        region_features (Region_Esp_Sup, 'area', Area_Sup)</l>
<c>        </c>
<c>        * Porcentaje del area ocupada respecto a region total</c>
<l>        per_OK:=Area_OK/AreaTotal*100</l>
<l>        per_Inf:=Area_Inf/AreaTotal*100</l>
<l>        per_Sup:=Area_Sup/AreaTotal*100</l>
<c>        </c>
<c>        * debug</c>
<l>        total_per:=round(per_Sup+per_OK+per_Inf)    </l>
<l>        if (total_per!=100)</l>
<l>            throw (['Calculo de area incorrecto'])</l>
<l>        endif        </l>
<c>            </c>
<c>        * Se comprueba si el porcentaje de area dentro de los limites </c>
<c>        * cumple con el minimo estipulado</c>
<l>        if (per_OK&gt;=Umbral_Esp_Medio)</l>
<c>            </c>
<c>            * Control OK con cualquier calidad</c>
<l>            Codigo_Error := 0</l>
<c>            </c>
<c>            * La clase se identifica con el indice</c>
<l>            Calidad := Index            </l>
<c>            </c>
<c>            * Si es 1 ya se sale del bucle si no se comprueba calidad 2 </c>
<c>            * Si no se entra en ninguna de las dos calidades la calidad no se modifica</c>
<c>            * y sigue en -1 como se definio al principio</c>
<l>        else            </l>
<c>            * No cumple espesor medio</c>
<l>            Codigo_Error:=113           </l>
<l>        endif        </l>
<l>    endfor      </l>
<l>else           </l>
<c>    </c>
<c>    * Error variable no inicializada</c>
<l>    gen_empty_obj (Region_Esp_OK)</l>
<l>    gen_empty_obj (Region_Esp_Inf)</l>
<l>    gen_empty_obj (Region_Esp_Sup)</l>
<l>    Valores_MinMax:=[-1,-1,-1,-1]</l>
<c>    </c>
<c>    * No cumple espesor minimo</c>
<l>    Codigo_Error:=112    </l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Control_Espesor">
<parameters>
<parameter id="Calidad"/>
<parameter id="Codigo_Error"/>
<parameter id="Dict_Var_Prod"/>
<parameter id="Espesor_Maximo"/>
<parameter id="Espesor_Medio"/>
<parameter id="Espesor_Minimo"/>
<parameter id="Espesor_Nominal"/>
<parameter id="Image"/>
<parameter id="Region"/>
<parameter id="Region_Esp_Inf"/>
<parameter id="Region_Esp_OK"/>
<parameter id="Region_Esp_Sup"/>
<parameter id="Umbral_Esp_Medio"/>
<parameter id="Valores_MinMax"/>
<parameter id="per_OK"/>
</parameters>
</docu>
</procedure>
<procedure name="image_border">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="Region" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="IsOnBorder" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Comprueba si una region toca los bordes de la imagen. Para ello,</c>
<c>* se define un margen interior en los cuatro lados de la imagen</c>
<c>* y se verifica si hay interseccion con la region de entrada.</c>
<c></c>
<c>* ENTRADAS (icono):</c>
<c>* - Image  : imagen de referencia</c>
<c>* - Region : region a comprobar</c>
<c></c>
<c>* SALIDAS (control):</c>
<c>* - IsOnBorder : 1 si hay interseccion con borde, 0 si no</c>
<c>********************************************************************************</c>
<c></c>
<l>if (false)</l>
<l>    dev_clear_window ()</l>
<l>    dev_display (Image)</l>
<l>    dev_display (Region)</l>
<l>endif</l>
<c></c>
<c>* Cuanto se van a mover hacia adentro los bordes</c>
<l>Margen:=3</l>
<c></c>
<c>* Dimensiones de imagen</c>
<l>get_image_size (Image, Width, Height)</l>
<c></c>
<c>* Crear regiones que representan los bordes de la imagen</c>
<l>gen_rectangle1 (TopBorder, 0, 0, 0, Width - Margen)</l>
<l>gen_rectangle1 (BottomBorder, Height - Margen, 0, Height - Margen, Width - Margen)</l>
<l>gen_rectangle1 (LeftBorder, 0, 0, Height - Margen, 0)</l>
<l>gen_rectangle1 (RightBorder, 0, Width - Margen, Height - Margen, Width - Margen)</l>
<c></c>
<c>* Unir todas las regiones de borde</c>
<l>union2 (TopBorder, BottomBorder, HBorder)</l>
<l>union2 (LeftBorder, RightBorder, VBorder)</l>
<l>union2 (HBorder, VBorder, ImageBorder)</l>
<c></c>
<c>* Verificar intersección</c>
<l>intersection (Region, ImageBorder, BorderRegion)</l>
<l>area_center (BorderRegion, Area, Row, Column)</l>
<c></c>
<l>tuple_sum (Area, Area)</l>
<l>if (Area &gt; 0)</l>
<l>    IsOnBorder := 1</l>
<l>else</l>
<l>    IsOnBorder := 0</l>
<l>endif</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="image_border">
<parameters>
<parameter id="Image"/>
<parameter id="IsOnBorder"/>
<parameter id="Region"/>
</parameters>
</docu>
</procedure>
<procedure name="distancia_mm_v2">
<interface>
<io>
<par name="X" base_type="iconic" dimension="0"/>
<par name="Y" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="row1" base_type="ctrl" dimension="0"/>
<par name="col1" base_type="ctrl" dimension="0"/>
<par name="row2" base_type="ctrl" dimension="0"/>
<par name="col2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="distancia" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Calcula la distancia en mm entre dos puntos definidos por coordenadas</c>
<c>* de imagen, utilizando las imágenes de escala X e Y.</c>
<c></c>
<c>* ENTRADAS (icono):</c>
<c>* - X              : imagen con coordenadas X reales</c>
<c>* - Y              : imagen con coordenadas Y reales</c>
<c></c>
<c>* ENTRADAS (control):</c>
<c>* - row1           : coordenada fila del primer punto</c>
<c>* - col1           : coordenada columna del primer punto</c>
<c>* - row2           : coordenada fila del segundo punto</c>
<c>* - col2           : coordenada columna del segundo punto</c>
<c></c>
<c>* SALIDAS (control):</c>
<c>* - distancia      : distancia euclidea entre puntos en mm</c>
<c>********************************************************************************</c>
<c></c>
<c>* Obtener coordenadas reales del punto 1</c>
<l>get_grayval (X, 0, col1, p1x)</l>
<l>get_grayval (Y, row1, 0, p1y)</l>
<c></c>
<c>* Obtener coordenadas reales del punto 2</c>
<l>get_grayval (X, 0, col2, p2x)</l>
<l>get_grayval (Y, row2, 0, p2y)</l>
<c></c>
<c>* Calcular diferencias</c>
<l>distancia_x := p2x-p1x</l>
<l>distancia_y := p2y-p1y</l>
<c></c>
<c>* Calcular distancia euclidea</c>
<l>tuple_sqrt ((distancia_x*distancia_x) + (distancia_y*distancia_y), distancia)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="distancia_mm_v2">
<parameters>
<parameter id="X"/>
<parameter id="Y"/>
<parameter id="col1"/>
<parameter id="col2"/>
<parameter id="distancia"/>
<parameter id="row1"/>
<parameter id="row2"/>
</parameters>
</docu>
</procedure>
<procedure name="Variables_Planeidad">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="X" base_type="iconic" dimension="0"/>
<par name="Y" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionPlan" base_type="iconic" dimension="0"/>
<par name="ImagePlan" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Margin" base_type="ctrl" dimension="0"/>
<par name="Pixel_Size" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Se preparan los datos iconicos para el control de planeidad. A partir</c>
<c>* de una region binaria se genera una subregion erosionada centrada y </c>
<c>* alineada, para excluir los bordes externos. La imagen se reduce </c>
<c>* a esa zona para facilitar el analisis posterior.</c>
<c>*</c>
<c>* ENTRADAS (icono):</c>
<c>* - Region      : region binaria completa de la pieza</c>
<c>* - Image       : imagen de profundidad original</c>
<c>* - X           : imagen de coordenadas X reales (en mm)</c>
<c>* - Y           : imagen de coordenadas Y reales (en mm)</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* - Margin      : margen interior en mm a eliminar</c>
<c>* - Pixel_Size  : tupla con tamaño de pixel en X e Y (en mm)</c>
<c>*</c>
<c>* SALIDAS (icono):</c>
<c>* - RegionPlan  : region erosionada alineada y centrada</c>
<c>* - ImagePlan   : imagen reducida a la region erosionada</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* - Codigo_Error: reserva</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<c>** test **</c>
<l>test:=false</l>
<l>if (test)</l>
<l>    dev_clear_window ()</l>
<l>    dev_display (Image)</l>
<l>    dev_display (Region)</l>
<l>    dev_display (Image)</l>
<l>endif</l>
<c></c>
<c>* Comprobacion pixel cuadrado</c>
<l>if (abs(Pixel_Size[0] - Pixel_Size[1]) &gt; 1e-6)</l>
<l>    throw (['Revisar dimensiones pixel'])</l>
<l>endif</l>
<c></c>
<l>Margin_Pixel:=round((Margin*2)/Pixel_Size[0])</l>
<c></c>
<c>* Orientacion de rectangulo normalizado</c>
<l>orientation_region (Region, Phi)</l>
<c></c>
<c>* Centro rectangulo normalizado</c>
<l>area_center (Region, Area, RowCenter, ColCenter)</l>
<l>gen_cross_contour_xld (Cross1, RowCenter, ColCenter, 60, Phi)</l>
<c></c>
<c>* Mover a angulo recto para realizar erosion</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -Phi, RowCenter, ColCenter, HomMat2DRotate)</l>
<l>affine_trans_region (Region, RegionRot, HomMat2DRotate, 'nearest_neighbor')</l>
<c></c>
<c>* Erosionar en angulo recto</c>
<l>erosion_rectangle1 (RegionRot, RegionPlan, Margin_Pixel, Margin_Pixel)</l>
<c></c>
<c>* Volver a inclinacion orignal</c>
<l>hom_mat2d_rotate (HomMat2DIdentity, Phi, RowCenter, ColCenter, HomMat2DRotate)</l>
<l>affine_trans_region (RegionPlan, RegionPlan, HomMat2DRotate, 'nearest_neighbor')</l>
<c></c>
<c>* Reducir imagen</c>
<l>reduce_domain (Image, RegionPlan, ImagePlan)</l>
<c></c>
<c>** test **</c>
<l>if (test)</l>
<l>    dev_set_color ('red')</l>
<l>    dev_clear_window ()</l>
<l>    dev_display (Region)</l>
<l>    dev_set_color ('blue')</l>
<l>    dev_display (RegionPlan)</l>
<c>    </c>
<c>    * Distancia minima entre dos regiones</c>
<l>    distance_rr_min (Region, RegionPlan, MinDistance, Row1, Column1, Row2, Column2)</l>
<c>    </c>
<c>    * Dibujar o usar el puntos medidos</c>
<l>    gen_cross_contour_xld(Cross1, Row1, Column1, 60, 0)</l>
<l>    gen_cross_contour_xld(Cross2, Row2, Column2, 60, 0)    </l>
<c>    </c>
<l>    dev_display (RegionPlan)</l>
<l>    dev_display (RegionPlan)</l>
<c>    </c>
<l>    distancia_mm_v2 (X, Y, Row1, Column1, Row2, Column2, distancia)</l>
<l>    dev_disp_text (distancia, 'image', 0, 0, 'black', [], [])  </l>
<c>    </c>
<c>    * Contornos de region original</c>
<l>    gen_contour_region_xld (Region, Contours, 'border')</l>
<l>    gen_polygons_xld (Contours, ContoursGen, 'ramer', 2)</l>
<c>    </c>
<c>    * Contornos de region erosionada</c>
<l>    gen_contour_region_xld (RegionPlan, ContoursErosion, 'border')</l>
<l>    gen_polygons_xld (ContoursErosion, ContoursErosionGen, 'ramer', 2)</l>
<c></c>
<c>    * Calcular distancia minima entre 2 puntos</c>
<l>    distance_cc_min_points (Contours, ContoursErosion, 'fast_point_to_segment', DistanceMin, Row1, Column1, Row2, Column2)</l>
<c>    </c>
<c>    * Dibujar o usar el puntos medidos</c>
<l>    gen_cross_contour_xld(Cross, Row1, Column1, 60, 0)</l>
<l>    gen_cross_contour_xld(Cross, Row2, Column2, 60, 0)    </l>
<c>    </c>
<l>    distancia_mm_v2 (X, Y, Row1, Column1, Row2, Column2, distancia)</l>
<l>    dev_disp_text (distancia, 'image', 0, 0, 'black', [], [])    </l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Variables_Planeidad">
<parameters>
<parameter id="Codigo_Error"/>
<parameter id="Image"/>
<parameter id="ImagePlan"/>
<parameter id="Margin"/>
<parameter id="Pixel_Size"/>
<parameter id="Region"/>
<parameter id="RegionPlan"/>
<parameter id="X"/>
<parameter id="Y"/>
</parameters>
</docu>
</procedure>
<procedure name="Read_Inputs_PLC">
<interface>
<ic>
<par name="Io_Espesor_Nominal" base_type="ctrl" dimension="0"/>
<par name="Io_Control_Esquinas_1" base_type="ctrl" dimension="0"/>
<par name="Io_Control_Esquinas_2" base_type="ctrl" dimension="0"/>
<par name="Io_Control_Perforaciones_1" base_type="ctrl" dimension="0"/>
<par name="Io_Control_Perforaciones_2" base_type="ctrl" dimension="0"/>
<par name="Io_Produccion" base_type="ctrl" dimension="0"/>
<par name="Io_ID_Pizarra_In" base_type="ctrl" dimension="0"/>
<par name="Io_Cargar_Fichero_1" base_type="ctrl" dimension="0"/>
<par name="Io_Cargar_Fichero_2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Espesor_Nominal" base_type="ctrl" dimension="0"/>
<par name="Control_Esquinas_1" base_type="ctrl" dimension="0"/>
<par name="Control_Esquinas_2" base_type="ctrl" dimension="0"/>
<par name="Control_Perforaciones_1" base_type="ctrl" dimension="0"/>
<par name="Control_Perforaciones_2" base_type="ctrl" dimension="0"/>
<par name="Produccion" base_type="ctrl" dimension="0"/>
<par name="ID_Pizarra_In" base_type="ctrl" dimension="0"/>
<par name="Cargar_Fichero_1" base_type="ctrl" dimension="0"/>
<par name="Cargar_Fichero_2" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Lee los parametros del PLC a traves de canales OPC UA.</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c></c>
<c>* -Io_Espesor_Nominal        : canal OPC espesor nominal</c>
<c>* -Io_Control_Esquinas_1     : canal OPC activar control esquinas apilador 1</c>
<c>* -Io_Control_Esquinas_2     : canal OPC activar control esquinas apilador 2</c>
<c>* -Io_Control_Perforaciones_1: canal OPC produccion 1 con perforaciones</c>
<c>* -Io_Control_Perforaciones_2: canal OPC produccion 2 con perforaciones</c>
<c>* -Io_Produccion             : canal OPC apilador ciclo actual</c>
<c>* -Io_ID_Pizarra_In          : canal OPC ID de pizarra</c>
<c></c>
<c>* SALIDAS (control):</c>
<c>* -Espesor_Nominal         : espesor nominal</c>
<c>* -Control_Esquinas_1      : activar control esquinas pizarras apilador 1</c>
<c>* -Control_Esquinas_2      : activar control esquinas pizarras apilador 2</c>
<c>* -Control_Perforaciones_1 : activar perforaciones pizarras apilador 1</c>
<c>* -Control_Perforaciones_2 : activar perforaciones pizarras apilador 2</c>
<c>* -Produccion              : apilador ciclo actual</c>
<c>* -ID_Pizarra_In           : identificador de la pieza</c>
<c>* -Codigo_Error            : 0 = OK</c>
<c>*                          : 9998 = error lectura canales OPC UA</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<l>try</l>
<c>        </c>
<c>    * Io_Espesor_Nominal </c>
<l>    read_io_channel (Io_Espesor_Nominal, Espesor_Nominal, Status)</l>
<c>    </c>
<c>    * Valor en mm con decimales</c>
<l>    Espesor_Nominal:=Espesor_Nominal/1000.0</l>
<c>    </c>
<c>    * Io_Control_Esquinas_1</c>
<l>    read_io_channel (Io_Control_Esquinas_1, Control_Esquinas_1, Status)</l>
<c>    </c>
<c>    * Io_Control_Esquinas_2</c>
<l>    read_io_channel (Io_Control_Esquinas_2, Control_Esquinas_2, Status)</l>
<c>    </c>
<c>    * Io_Control_Perforaciones_1</c>
<l>    read_io_channel (Io_Control_Perforaciones_1, Control_Perforaciones_1, Status)</l>
<c>    </c>
<c>    * Io_Control_Perforaciones_2</c>
<l>    read_io_channel (Io_Control_Perforaciones_2, Control_Perforaciones_2, Status)</l>
<c>    </c>
<c>    * Io_Produccion</c>
<l>    read_io_channel (Io_Produccion, Produccion, Status)</l>
<c>    </c>
<c>    * Io_ID_Pizarra_In</c>
<l>    read_io_channel (Io_ID_Pizarra_In, ID_Pizarra_In, Status)    </l>
<c>       </c>
<c>    * Io_Cargar_Fichero_1</c>
<l>    read_io_channel (Io_Cargar_Fichero_1, Cargar_Fichero_1, Status)</l>
<c>    </c>
<c>    * Io_Cargar_Fichero_2</c>
<l>    read_io_channel (Io_Cargar_Fichero_2, Cargar_Fichero_2, Status) </l>
<l>catch (Exception)</l>
<c>    </c>
<c>    * Error lectura canales OPC UA</c>
<l>    Codigo_Error:=9998</l>
<l>endtry</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Read_Inputs_PLC">
<parameters>
<parameter id="Cargar_Fichero_1"/>
<parameter id="Cargar_Fichero_2"/>
<parameter id="Codigo_Error"/>
<parameter id="Control_Esquinas_1"/>
<parameter id="Control_Esquinas_2"/>
<parameter id="Control_Perforaciones_1"/>
<parameter id="Control_Perforaciones_2"/>
<parameter id="Espesor_Nominal"/>
<parameter id="ID_Pizarra_In"/>
<parameter id="Io_Cargar_Fichero_1"/>
<parameter id="Io_Cargar_Fichero_2"/>
<parameter id="Io_Control_Esquinas_1"/>
<parameter id="Io_Control_Esquinas_2"/>
<parameter id="Io_Control_Perforaciones_1"/>
<parameter id="Io_Control_Perforaciones_2"/>
<parameter id="Io_Espesor_Nominal"/>
<parameter id="Io_ID_Pizarra_In"/>
<parameter id="Io_Produccion"/>
<parameter id="Produccion"/>
</parameters>
</docu>
</procedure>
<procedure name="Write_Outputs_PLC">
<interface>
<ic>
<par name="Io_Codigo_Error" base_type="ctrl" dimension="0"/>
<par name="Io_Largo_Medido" base_type="ctrl" dimension="0"/>
<par name="Io_Ancho_Medido" base_type="ctrl" dimension="0"/>
<par name="Io_Espesor_Medido" base_type="ctrl" dimension="0"/>
<par name="Io_Tercio_Visible" base_type="ctrl" dimension="0"/>
<par name="Io_Calidad_Tercio_1" base_type="ctrl" dimension="0"/>
<par name="Io_Calidad_Tercio_3" base_type="ctrl" dimension="0"/>
<par name="Io_ID_Pizarra_Out" base_type="ctrl" dimension="0"/>
<par name="Largo_Medido" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
<par name="Ancho_Medido" base_type="ctrl" dimension="0"/>
<par name="Espesor_Medido" base_type="ctrl" dimension="0"/>
<par name="Tercio_Visible" base_type="ctrl" dimension="0"/>
<par name="Calidad_Tercio_1" base_type="ctrl" dimension="0"/>
<par name="Calidad_Tercio_3" base_type="ctrl" dimension="0"/>
<par name="ID_Pizarra_Out" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Escribe los resultados del analisis de la pieza en los canales OPC UA </c>
<c>* del PLC. Incluye ID, posicion del centro, orientacion, dimensiones, </c>
<c>* calidad y visibilidad por tercios.</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* -Io_Codigo_Error           : canal OPC codigo de error</c>
<c>* -Io_Vision_Realizada       : canal OPC vision realizada</c>
<c>* -Io_Largo_Medido           : canal OPC largo medido</c>
<c>* -Io_Ancho_Medido           : canal OPC ancho medido</c>
<c>* -Io_Espesor_Medido         : canal OPC espesor medido</c>
<c>* -Io_Tercio_Visible         : canal OPC tercio seleccionado para parte visible</c>
<c>* -Io_Calidad_Tercio_1       : canal OPC calidad de tercio 1 (primero en pasar fotocelula)</c>
<c>* -Io_Calidad_Tercio_3       : canal OPC calidad de tercio 3 (ultimo en pasar fotocelula)</c>
<c>* -Io_Fichero_Cargado_1      : canal OPC fichero cargado apilador 1</c>
<c>* -Io_Fichero_Cargado_2      : canal OPC fichero cargado apilador 2</c>
<c>* -Io_ID_Pizarra_Out         : canal OPC echo ID pizarra</c>
<c>*</c>
<c>* -Codigo_Error           : codigo de error del ciclo</c>
<c>* -Vision_Realizada       : vision realizada</c>
<c>* -Largo_Medido           : largo medido</c>
<c>* -Ancho_Medido           : ancho medido</c>
<c>* -Espesor_Medido         : espesor medido</c>
<c>* -Tercio_Visible         : tercio seleccionado para parte visible</c>
<c>* -Calidad_Tercio_1       : calidad de tercio 1 (primero en pasar fotocelula)</c>
<c>* -Calidad_Tercio_3       : calidad de tercio 3 (ultimo en pasar fotocelula)</c>
<c>* -ID_Pizarra_Out         : echo ID pizarra</c>
<c>********************************************************************************</c>
<c></c>
<c>* Codigo_Error</c>
<l>write_io_channel (Io_Codigo_Error, Codigo_Error, Status)</l>
<c></c>
<c>* Largo_Medido</c>
<l>write_io_channel (Io_Largo_Medido, Largo_Medido*1000, Status)</l>
<c></c>
<c>* Ancho_Medido</c>
<l>write_io_channel (Io_Ancho_Medido, Ancho_Medido*1000, Status)</l>
<c></c>
<c>* Espesor_Medido</c>
<l>write_io_channel (Io_Espesor_Medido, Espesor_Medido*1000, Status)</l>
<c></c>
<c>* Tercio_Visible</c>
<l>write_io_channel (Io_Tercio_Visible, Tercio_Visible, Status)</l>
<c></c>
<c>* Calidad_Tercio_1</c>
<l>write_io_channel (Io_Calidad_Tercio_1, Calidad_Tercio_1, Status)</l>
<c></c>
<c>* Calidad_Tercio_3</c>
<l>write_io_channel (Io_Calidad_Tercio_3, Calidad_Tercio_3, Status)</l>
<c></c>
<c>* ID_Pizarra_Out</c>
<l>write_io_channel (Io_ID_Pizarra_Out, ID_Pizarra_Out, Status)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Write_Outputs_PLC">
<parameters>
<parameter id="Ancho_Medido"/>
<parameter id="Calidad_Tercio_1"/>
<parameter id="Calidad_Tercio_3"/>
<parameter id="Codigo_Error"/>
<parameter id="Espesor_Medido"/>
<parameter id="ID_Pizarra_Out"/>
<parameter id="Io_Ancho_Medido"/>
<parameter id="Io_Calidad_Tercio_1"/>
<parameter id="Io_Calidad_Tercio_3"/>
<parameter id="Io_Codigo_Error"/>
<parameter id="Io_Espesor_Medido"/>
<parameter id="Io_ID_Pizarra_Out"/>
<parameter id="Io_Largo_Medido"/>
<parameter id="Io_Tercio_Visible"/>
<parameter id="Largo_Medido"/>
<parameter id="Tercio_Visible"/>
</parameters>
</docu>
</procedure>
<procedure name="Secuencia_VR_RV">
<interface>
<ic>
<par name="Io_Realizar_Vision" base_type="ctrl" dimension="0"/>
<par name="Io_Vision_Realizada" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Sincroniza el ciclo de vision con el PLC. Espera la senal de solicitud</c>
<c>* 'Realizar_Vision' y mientras esta activa, mantiene 'Vision_Realizada'</c>
<c>* a 'true'. Cuando la senal se desactiva, la respuesta tambien se pone a 'false'.</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* - IoRealizar_Vision   : canal OPC UA que indica si se debe ejecutar vision</c>
<c>* - IoVision_Realizada  : canal OPC UA que informa si la vision se ha realizado</c>
<c>********************************************************************************</c>
<c></c>
<c>* Leer el valor de la senal del PLC para iniciar la vision</c>
<l>read_io_channel (Io_Realizar_Vision, RV, Status)</l>
<c></c>
<c>* Mientras la senal este activa, mantener la respuesta activa</c>
<l>while (RV == 'true')  </l>
<c>    </c>
<c>    * Leer nuevamente el estado para comprobar si se ha liberado</c>
<l>    read_io_channel (Io_Realizar_Vision, RV, Status)</l>
<c>    </c>
<c>    * Enviar respuesta al PLC indicando que se ha realizado la vision</c>
<l>    write_io_channel (Io_Vision_Realizada, 'true', Status)</l>
<l>endwhile         </l>
<c></c>
<c>* Finalizar respuesta al PLC</c>
<l>write_io_channel (Io_Vision_Realizada, 'false', Status)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Secuencia_VR_RV">
<parameters>
<parameter id="Io_Realizar_Vision"/>
<parameter id="Io_Vision_Realizada"/>
</parameters>
</docu>
</procedure>
<procedure name="Control_Area">
<interface>
<io>
<par name="Z" base_type="iconic" dimension="0"/>
<par name="Rectangle_Norm" base_type="iconic" dimension="0"/>
<par name="OriginalRegion" base_type="iconic" dimension="0"/>
<par name="Bordes_Norm" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="AreaFaults" base_type="iconic" dimension="0"/>
<par name="Corner_Faults" base_type="iconic" dimension="0"/>
<par name="Rectangle_Norm_Esq" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Corner_Rows" base_type="ctrl" dimension="0"/>
<par name="Corner_Cols" base_type="ctrl" dimension="0"/>
<par name="xTolerance" base_type="ctrl" dimension="0"/>
<par name="yTolerance" base_type="ctrl" dimension="0"/>
<par name="Tol_Esq_Rotas" base_type="ctrl" dimension="0"/>
<par name="Area_Min_Error" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Esquinas_Rotas" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Detecta defectos en las esquinas de una pieza comparando la forma real</c>
<c>* con un rectangulo normalizado. Genera tolerancia en las esquinas para</c>
<c>* permitir pequeñas ausencias de material. Determina si hay defecto dentro</c>
<c>* o fuera de la zona tolerada y marca cada esquina como valida o rota.</c>
<c>*</c>
<c>* ENTRADAS (icono):</c>
<c>* -Z                 : imagen original (alturas o profundidad, para visualizacion opcional)</c>
<c>* -Rectangle_Norm    : rectangulo normalizado de referencia</c>
<c>* -OriginalRegion    : region real extraida de la pieza</c>
<c>* -Bordes_Norm       : conjunto de bordes normalizados</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* -Corner_Rows       : coordenadas fila de las 4 esquinas</c>
<c>* -Corner_Cols       : coordenadas columna de las 4 esquinas</c>
<c>* -xTolerance        : tolerancia en X excpecion esquinas rotas </c>
<c>* -yTolerance        : tolerancia en X excpecion esquinas rotas</c>
<c>* -Tol_Esq_Rotas     : numero de esquinas rotas permitidas por debajo de la tolerancia</c>
<c>* -Area_Min_Error    : area minima en pixeles para que cuente como error</c>
<c>*</c>
<c>* SALIDAS (icono):</c>
<c>* -AreaFaults        : regiones donde falta material</c>
<c>* -Corner_Faults     : esquinas identificadas como defectuosas</c>
<c>* -Rectangle_Norm_Esq: rectangulo normalizado sin las zonas toleradas</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* -Esquinas_Rotas    : tupla binaria indicando que esquinas fallan [0,1,...]</c>
<c>* -Codigo_Error      : 0 = OK</c>
<c>*                      100 = defecto esquina fuera de tolerancia</c>
<c>*                      101 = varias esquinas con defecto dentro de tolerancia</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<l>if (false)</l>
<l>    dev_clear_window ()</l>
<l>    dev_display (Z)</l>
<l>    dev_set_color ('red')            </l>
<l>endif</l>
<c></c>
<c>* Inicializar vector de estado de esquinas</c>
<l>Esquinas_Rotas:=[0,0,0,0]</l>
<c></c>
<c>* Obtener orientacion del rectangulo normalizado</c>
<l>smallest_rectangle2 (Rectangle_Norm, Row, Column, Phi, Length1, Length2)</l>
<c></c>
<c>* Generar las 4 regiones de esquina con tolerancia</c>
<l>gen_rectangle2 (Esquina1, Corner_Rows[0], Corner_Cols[0], Phi, xTolerance, yTolerance)</l>
<l>gen_rectangle2 (Esquina2, Corner_Rows[1], Corner_Cols[1], Phi, xTolerance, yTolerance)</l>
<l>gen_rectangle2 (Esquina3, Corner_Rows[2], Corner_Cols[2], Phi, xTolerance, yTolerance)</l>
<l>gen_rectangle2 (Esquina4, Corner_Rows[3], Corner_Cols[3], Phi, xTolerance, yTolerance)</l>
<c></c>
<c>* Ajustar las regiones de esquina al rectangulo normalizado</c>
<l>intersection (Esquina1, Rectangle_Norm, Esquina1)</l>
<l>intersection (Esquina2, Rectangle_Norm, Esquina2)</l>
<l>intersection (Esquina3, Rectangle_Norm, Esquina3)</l>
<l>intersection (Esquina4, Rectangle_Norm, Esquina4)</l>
<c></c>
<c>* Restar esquinas toleradas del rectangulo para obtener zona critica</c>
<l>difference (Rectangle_Norm, Esquina1 , Rectangle_Norm_Esq)</l>
<l>difference (Rectangle_Norm_Esq, Esquina2 , Rectangle_Norm_Esq)</l>
<l>difference (Rectangle_Norm_Esq, Esquina3 , Rectangle_Norm_Esq)</l>
<l>difference (Rectangle_Norm_Esq, Esquina4 , Rectangle_Norm_Esq)</l>
<c></c>
<c>* Comparar region completa contra la original</c>
<l>difference (Rectangle_Norm, OriginalRegion, RegionDifference)</l>
<c></c>
<c>* Eliminar residuos y separar por objetos</c>
<l>opening_circle (RegionDifference, RegionOpening, 3.5)</l>
<l>connection (RegionOpening, ConnectedRegions)</l>
<c></c>
<c>* Evaluar el area de las regiones faltantes</c>
<l>region_features (ConnectedRegions, 'area', AreaValues)</l>
<l>tuple_max (AreaValues, Max)</l>
<l>tuple_sum (AreaValues, Sum)</l>
<c></c>
<c>* Inicializar objeto vacio y tupla de resultado</c>
<l>gen_empty_obj (AreaFaults)</l>
<l>Esquinas_Rotas:=[0,0,0,0]</l>
<c></c>
<c>* Evaluar si hay defecto significativo</c>
<c>* 200: Valor minimo estimado</c>
<l>if (AreaValues&gt;0 and Max&gt;Area_Min_Error)</l>
<c>    </c>
<c>    * Seleccionar solo regiones con area significativa</c>
<l>    select_shape (ConnectedRegions, AreaFaults, 'area', 'and',Area_Min_Error , Max)     </l>
<c>    </c>
<c>    * Verificar si alguna interseca fuera de las esquinas toleradas</c>
<l>    intersection (AreaFaults, Rectangle_Norm_Esq, RegionDescarte)</l>
<l>    area_center (RegionDescarte, Area, Row, Column)</l>
<l>    tuple_sum (Area, Area)</l>
<c>    </c>
<l>    if (Area=0)</l>
<c>        * Solo se detecta defecto dentro de esquinas toleradas</c>
<c>    </c>
<c>        * Crear array de esquinas para iterar</c>
<l>        gen_empty_obj (EsquinasConcat)</l>
<l>        concat_obj (EsquinasConcat, Esquina1, EsquinasConcat)</l>
<l>        concat_obj (EsquinasConcat, Esquina2, EsquinasConcat)</l>
<l>        concat_obj (EsquinasConcat, Esquina3, EsquinasConcat)</l>
<l>        concat_obj (EsquinasConcat, Esquina4, EsquinasConcat)</l>
<c>            </c>
<l>        gen_empty_obj (Corner_Faults)</l>
<l>        for Index := 1 to 4 by 1</l>
<c>            </c>
<c>            * Extraer una esquina</c>
<l>            select_obj (EsquinasConcat, ObjectSelected, Index)</l>
<c>            </c>
<c>            * Verificar interseccion con las regiones faltantes</c>
<l>            intersection (ObjectSelected,AreaFaults,AreaFaultsEsq)</l>
<l>            area_center (AreaFaultsEsq, Area, Row, Column)</l>
<l>            tuple_sum (Area, Area)</l>
<c>            </c>
<l>            if (Area&gt;0)</l>
<c>                * Marcar esquina como defectuosa</c>
<l>                Esquinas_Rotas[Index-1]:=1</l>
<l>                concat_obj (Corner_Faults, ObjectSelected, Corner_Faults)</l>
<l>            endif</l>
<l>        endfor</l>
<c>        </c>
<l>        tuple_find (Esquinas_Rotas, 1, Indices)</l>
<l>        tuple_length (Indices, Length)</l>
<l>        if (Length&gt;Tol_Esq_Rotas)</l>
<c> </c>
<c>            * Varias esquinas con defecto dentro de tolerancia</c>
<l>            Codigo_Error:= 101  </l>
<l>        endif</l>
<l>    else</l>
<c>        * Defecto esquina fuera de tolerancia</c>
<l>        Codigo_Error:= 100</l>
<l>    endif </l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Control_Area">
<parameters>
<parameter id="AreaFaults"/>
<parameter id="Area_Min_Error"/>
<parameter id="Bordes_Norm"/>
<parameter id="Codigo_Error"/>
<parameter id="Corner_Cols"/>
<parameter id="Corner_Faults"/>
<parameter id="Corner_Rows"/>
<parameter id="Esquinas_Rotas"/>
<parameter id="OriginalRegion"/>
<parameter id="Rectangle_Norm"/>
<parameter id="Rectangle_Norm_Esq"/>
<parameter id="Tol_Esq_Rotas"/>
<parameter id="Z"/>
<parameter id="xTolerance"/>
<parameter id="yTolerance"/>
</parameters>
</docu>
</procedure>
<procedure name="Control_Largo">
<interface>
<ic>
<par name="Dimensiones" base_type="ctrl" dimension="0"/>
<par name="Dict_Var_Prod" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Verifica si el largo medido de una pieza esta dentro del margen de</c>
<c>* tolerancia respecto al valor nominal. Compara dos valores medidos en</c>
<c>* posiciones distintas y devuelve un codigo de error si alguno excede</c>
<c>* la tolerancia establecida.</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* -Dimensiones   : tupla de valores medidos (se usan indices 1 y 2)</c>
<c>* -Dict_Var_Prod : diccionaro con variables de produccion</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* -Codigo_Error  : 0   = OK</c>
<c>*                  110 = no cumple largo</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<c>* Se accede a los variables que necesitamos del diccionario</c>
<c>* de variables de produccion</c>
<l>get_dict_tuple(Dict_Var_Prod, 'Largo', Largo_Nominal)</l>
<l>get_dict_tuple(Dict_Var_Prod, 'Desviacion', DM_Longitud)</l>
<c></c>
<c>* Calcular diferencias respecto al largo nominal</c>
<l>Dif1:=Dimensiones[1]-Largo_Nominal</l>
<l>Dif2:=Dimensiones[2]-Largo_Nominal</l>
<l>Diff:=[Dif1,Dif2]</l>
<l>tuple_abs (Diff, Diff)</l>
<c></c>
<c>* Verificar si alguna diferencia excede el limite</c>
<l>if (Diff[0] &gt; DM_Longitud or Diff[1] &gt; DM_Longitud)    </l>
<c>    </c>
<c>    * No cumple largo</c>
<l>    Codigo_Error := 110</l>
<l>endif</l>
<c>                  </c>
<l>return ()</l>
</body>
<docu id="Control_Largo">
<parameters>
<parameter id="Codigo_Error"/>
<parameter id="Dict_Var_Prod"/>
<parameter id="Dimensiones"/>
</parameters>
</docu>
</procedure>
<procedure name="Control_Ancho">
<interface>
<ic>
<par name="Dimensiones" base_type="ctrl" dimension="0"/>
<par name="Dict_Var_Prod" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION :</c>
<c>* Verifica si el ancho medido de una pieza esta dentro del margen de</c>
<c>* tolerancia respecto al valor nominal. Compara dos posiciones distintas</c>
<c>* y devuelve un codigo de error si alguna esta fuera de rango.</c>
<c>*</c>
<c>* ENTRADAS (control)</c>
<c>* -Dimensiones     : tupla con valores medidos (se usan los indices 0 y 3)</c>
<c>* -Dict_Var_Prod   : diccionaro con variables de produccion</c>
<c>*</c>
<c>* SALIDAS (control)</c>
<c>* -Codigo_Error    : 0   = OK</c>
<c>*                    111 = no cumple ancho</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<c>* Se accede a los variables que necesitamos del diccionario</c>
<c>* de variables de produccion</c>
<l>get_dict_tuple(Dict_Var_Prod, 'Ancho', Ancho_Nominal)</l>
<l>get_dict_tuple(Dict_Var_Prod, 'Desviacion', DM_Anchura)</l>
<c></c>
<c>* Calcular diferencias respecto al ancho nominal</c>
<l>Dif1:=Dimensiones[0]-Ancho_Nominal</l>
<l>Dif2:=Dimensiones[3]-Ancho_Nominal</l>
<l>Diff:=[Dif1,Dif2]</l>
<l>tuple_abs (Diff, Diff)</l>
<c></c>
<c></c>
<c>* Verificar si alguna diferencia excede el limite</c>
<l>if (Diff[0] &gt;= DM_Anchura or Diff[1] &gt;= DM_Anchura)</l>
<c>    </c>
<c>    * No cumple ancho</c>
<l>    Codigo_Error := 111</l>
<l>endif   </l>
<c></c>
<l>return ()</l>
</body>
<docu id="Control_Ancho">
<parameters>
<parameter id="Codigo_Error"/>
<parameter id="Dict_Var_Prod"/>
<parameter id="Dimensiones"/>
</parameters>
</docu>
</procedure>
<procedure name="Save_HMI_Images">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Path" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Guarda una serie de imagenes numeradas a partir de la ultima captura.</c>
<c>* Si hay errores de lectura, se sustituye por una imagen de referencia</c>
<c>* corrupta. Se renombran las ultimas 10 imagenes (si existen) usando un</c>
<c>* patron de nombre predefinido (goc_sup_img_X). Si no hay imagenes,</c>
<c>* guarda solo la actual.</c>
<c>*</c>
<c>* ENTRADAS (icono):</c>
<c>* -Image       : imagen actual que se desea guardar</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* -Path        : ruta donde buscar y guardar las imagenes (*.bmp)</c>
<c>********************************************************************************</c>
<c></c>
<c>* Obtener el handle de la ventana actual</c>
<l>dev_get_window (WindowHandle)</l>
<c></c>
<c>* Contador de imagenes nuevas</c>
<l>cont := 0</l>
<c></c>
<c>* Prefijo para nombres de archivos</c>
<l>root:='goc_sup_img'</l>
<c></c>
<c>* Configurar fuente para visualización (opcional)</c>
<l>set_display_font (WindowHandle, 60, 'mono', 'true', 'false')</l>
<c></c>
<c>* Leer imagen de sustitucion para imagenes corruptas</c>
<l>Path_corrupted := Path + 'CORRUPTED_IMG/Corrupted.bmp'</l>
<l>read_image (Image_corrompidas, Path_corrupted)</l>
<c></c>
<c>* Obtener lista de imagenes en el directorio (formato BMP)</c>
<l>list_image_files (Path, 'bmp', [], Files)</l>
<l>Num_images := |Files|</l>
<c></c>
<c>* Recorrer imagenes existentes desde la mas reciente hacia atras</c>
<l>for Index := 1 to Num_images by 1</l>
<c>    </c>
<c>    * Intentar leer la imagen actual</c>
<l>    try</l>
<l>        read_image (ImagePrev, Files[Num_images - Index])</l>
<l>    catch (Exception)</l>
<c>        </c>
<c>        * Si falla, usar la imagen de respaldo</c>
<l>        ImagePrev := Image_corrompidas</l>
<l>    endtry</l>
<c></c>
<l>    if (Num_images-Index &gt;= 9)</l>
<c></c>
<c>         * Desplazar las imagenes hacia atras una posician</c>
<l>        try</l>
<l>            read_image (ImagePrev, Files[Num_images - Index -1])</l>
<l>        catch (Exception)</l>
<l>            ImagePrev := Image_corrompidas</l>
<l>        endtry</l>
<c></c>
<l>        indice := Num_images - Index</l>
<l>        write_image (ImagePrev, 'bmp', 0, Path + root +'_' + indice)</l>
<c></c>
<l>    else</l>
<c></c>
<c>        * Renombrar para mantener orden de las ultimas 9</c>
<l>        i := Num_images -Index +1</l>
<l>        write_image (ImagePrev, 'bmp', 0, Path + root +'_' + i)</l>
<c></c>
<l>        indice := Num_images - Index</l>
<l>        if (indice == 0)</l>
<c>            * Guardar la nueva imagen como la mas reciente</c>
<l>            write_image (Image, 'bmp', 0, Path + root +'_' + indice)</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c>* Si no habia imagenes, guardar esta como primera</c>
<l>if (Num_images == 0)</l>
<l>    write_image (Image, 'bmp', 0, Path + root +'_0.bmp')</l>
<l>endif</l>
<c></c>
<l>cont := cont + 1</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Save_HMI_Images">
<parameters>
<parameter id="Image"/>
<parameter id="Path"/>
</parameters>
</docu>
</procedure>
<procedure name="Calidad">
<interface>
<ic>
<par name="Calidades" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Calidad" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Determina la calidad global de una pizarra en base a las calidades</c>
<c>* obtenidas de diferentes controles parciales. </c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* -Calidades    : lista de calidades individuales</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* -Calidad      : calidad final asignada, 1 = primera, 2 = segunda</c>
<c>* -Codigo_Error : reserva</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<c>* Si no hay calidad 2 deben ser todo 1s</c>
<l>tuple_find (Calidades, 2, Indices)</l>
<c></c>
<l> if (Indices=-1)</l>
<l>     Calidad:=1</l>
<l> else</l>
<l>     Calidad:=2</l>
<l> endif</l>
<c>     </c>
<l>return ()</l>
<c></c>
<c>* Codigo de prueba para generar calidades random</c>
<l>if(0)</l>
<l>    tuple_rand (1,rand_value)</l>
<l>    if(rand_value&lt;=0.33)</l>
<l>        Calidad:=1</l>
<l>    elseif(rand_value&lt;=0.67)</l>
<l>        Calidad:=2</l>
<l>    else       </l>
<l>        Calidad:=3</l>
<l>    endif</l>
<l>endif</l>
<c>    </c>
<c></c>
</body>
<docu id="Calidad">
<parameters>
<parameter id="Calidad"/>
<parameter id="Calidades"/>
<parameter id="Codigo_Error"/>
</parameters>
</docu>
</procedure>
<procedure name="Tercios_Visibles">
<interface>
<ic>
<par name="Esquinas_Rotas" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Tercio_Visible" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Determina la visibilidad de los tercios de una pieza en funcion del estado</c>
<c>* de las esquinas y del codigo de error general. Asocia esquinas a tercios</c>
<c>* laterales, mientras que el tercio central se considera siempre visible si</c>
<c>* no hay errores globales.</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* - Esquinas_Rotas  : tupla binaria indicando que esquinas presentan defecto</c>
<c>*                     (orden [sup_izq, sup_der, inf_izq, inf_der])</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* - Tercio_Visible : se indica el tercio sin esquinas rotas ni perforaciones</c>
<c>* - Codigo_Error   :</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<c>* Falta por implementar las perforacines</c>
<c>* En principio solo puede haber una esquina rota en un tercio,</c>
<c>* de otro modo, se generaria un codigo de error, y ya no entraria aqui</c>
<l>if (Esquinas_Rotas[0]==1 or Esquinas_Rotas[1]==1)</l>
<l>    Tercio_Visible := 3</l>
<l>else</l>
<l>    Tercio_Visible := 1</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Tercios_Visibles">
<parameters>
<parameter id="Codigo_Error"/>
<parameter id="Esquinas_Rotas"/>
<parameter id="Tercio_Visible"/>
</parameters>
</docu>
</procedure>
<procedure name="Normalizar_Delta">
<interface>
<ic>
<par name="Delta" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Delta_Norm" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Normaliza una diferencia angular expresada en radianes al rango [-pi, pi].</c>
<c>* Este procedimiento permite comparar angulos teniendo en cuenta el salto</c>
<c>* ciclico de 360 grados (2*pi rad). Es util para evaluar orientaciones</c>
<c>* angulares de bordes, segmentos o objetos.</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* -Delta       : diferencia angular a normalizar (en radianes)</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* -Delta_Norm  : angulo normalizado en el rango [-pi, pi]</c>
<c>********************************************************************************</c>
<c></c>
<c>* Ejemplo de uso</c>
<l>Debug:=0</l>
<l>if (Debug)  </l>
<l>    angle1 :=rad(-170)</l>
<l>    angle2 :=rad(170)</l>
<l>    Delta := angle1-angle2</l>
<l>    Delta_deg := deg(Delta)</l>
<l>endif</l>
<c></c>
<l>pi:=rad(180)</l>
<c></c>
<c>* Módulo 2*pi "manual" para valores flotantes</c>
<l>tuple_floor (Delta / (2 * pi), Q)</l>
<l>Temp := Delta - Q * 2 * pi</l>
<c></c>
<c>* Ajustar a [-pi, pi]</c>
<l>if (Temp &gt; pi)</l>
<l>    Delta_Norm := Temp - 2 * pi</l>
<l>else</l>
<l>    Delta_Norm := Temp</l>
<l>endif</l>
<c></c>
<l>if (Debug)</l>
<c>    * Deberia dar 20</c>
<l>    Delta_Norm_Deg:= deg(Delta_Norm)  </l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Normalizar_Delta">
<parameters>
<parameter id="Delta"/>
<parameter id="Delta_Norm"/>
</parameters>
</docu>
</procedure>
<procedure name="Visu_Error_Funcionamiento">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Muestra mensajes visuales en pantalla correspondientes a errores de</c>
<c>* funcionamiento general del sistema, como ausencia de imagen o imagen</c>
<c>* fuera de campo de vision.</c>
<c></c>
<c>* ENTRADAS (control):</c>
<c>* - WindowHandle     : identificador de ventana HALCON</c>
<c>* - Codigo_Error     : codigo de error detectado (200, 201)</c>
<c>********************************************************************************</c>
<c></c>
<c>* Ajuste tamano fuente</c>
<l>set_display_font (WindowHandle, 18, 'mono', 'true', 'false')</l>
<l>dev_set_window (WindowHandle)</l>
<c></c>
<l>switch (Codigo_Error)</l>
<l>case 250:    </l>
<c></c>
<l>    dev_disp_text ('Sin objeto en la imagen','window','center', 'center', 'red', [], [])</l>
<l>    break</l>
<l>case 251:</l>
<l>    dev_display(Image)</l>
<l>    dev_disp_text ('Objeto fuera de campo de vision','window','center', 'center', 'red', [], [])</l>
<l>    break</l>
<c>    </c>
<l>endswitch</l>
<l>return ()</l>
</body>
<docu id="Visu_Error_Funcionamiento">
<parameters>
<parameter id="Codigo_Error"/>
<parameter id="Image"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="Segmentacion">
<interface>
<io>
<par name="Z" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="OriginalRegion" base_type="iconic" dimension="0"/>
<par name="ZRed" base_type="iconic" dimension="0"/>
<par name="GrayImageScaled" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Extrae la region principal de la imagen de profundidad, elimina ruido y</c>
<c>* genera una region convexa ajustada. Tambien produce una version reducida</c>
<c>* y escalada de la imagen Z y realiza validaciones de borde.</c>
<c>*</c>
<c>* ENTRADAS (icono):</c>
<c>* - Z               : imagen de profundidad (altura)</c>
<c>* - Image           : imagen visual de referencia</c>
<c>*</c>
<c>* SALIDAS (icono):</c>
<c>* - Region          : region convexa principal procesada</c>
<c>* - OriginalRegion  : region original sin transformar (para deteccion posterior)</c>
<c>* - ZRed            : imagen Z reducida al dominio de la region</c>
<c>* - GrayImageScaled : imagen de profundidad escalada a rango de grises 0-255</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* - Codigo_Error    : 0 = OK</c>
<c>*                   : 250 = sin objeto en la imagen </c>
<c>*                   : 251 = objeto fuera de campo de vision</c>
<c>********************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<c></c>
<c>* Aplica umbral para filtrar valores específicos de la imagen de profundidad</c>
<l>threshold (Z, Region, -10, 20)</l>
<c></c>
<c>* Seleccionar region mas grande para eliminar ruido</c>
<l>connection (Region, ConnectedRegions)</l>
<l>region_features (ConnectedRegions, 'area', Value)</l>
<l>tuple_max (Value, Max)</l>
<c></c>
<l>if (Max&gt;0)</l>
<c></c>
<l>    select_shape (ConnectedRegions, Region, 'area', 'and', Max, Max)</l>
<c>            </c>
<c>    * Se guarda la region original para la deteccion de esquinas</c>
<l>    OriginalRegion:=Region    </l>
<c>    </c>
<c>    * Generar envolvente convexa de la region</c>
<c>    * La envolvente convexa es la menor región convexa que contiene completamente a la región original.</c>
<c>    * Una región es convexa si, para cualquier par de puntos dentro de ella, la línea recta que los une también está completamente dentro de la región. </c>
<l>    shape_trans (Region, Region, 'convex')</l>
<c>    </c>
<c>    * Obtiene valores de profundidad mínima y máxima en la región seleccionada</c>
<l>    min_max_gray (Region, Z, 0.5, Min, Max, Range)</l>
<c>    </c>
<c>    * Reduce el dominio de una imagen</c>
<l>    reduce_domain (Z, Region, ZRed)</l>
<c>    </c>
<c>    * Escala los valores de gris de una escala a otra</c>
<l>    scale_image_range (ZRed, GrayImageScaled, [Min,0], [Max,255])</l>
<c>    </c>
<c>    * Convierte el tipo de una imagen</c>
<l>    convert_image_type (GrayImageScaled, GrayImageScaled, 'byte')</l>
<c>    </c>
<c>    * Detectar si la region esta fuera de la imagen</c>
<l>    image_border (Image, Region, IsOnBorder)</l>
<c>    </c>
<l>    if (IsOnBorder)</l>
<c>        * Objeto fuera de campo de vision</c>
<l>        Codigo_Error:=251</l>
<l>    endif</l>
<l>else</l>
<c>    * Sin objeto en la imagen </c>
<l>    Codigo_Error:=250</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Segmentacion">
<short lang="es_ES">Extrae la region principal de la imagen de profundidad, elimina ruido y genera una region convexa ajustada. Tambien produce una version reducida y escalada de la imagen Z y realiza validaciones de borde.</short>
<parameters>
<parameter id="Codigo_Error"/>
<parameter id="GrayImageScaled"/>
<parameter id="Image"/>
<parameter id="OriginalRegion"/>
<parameter id="Region"/>
<parameter id="Z"/>
<parameter id="ZRed"/>
</parameters>
</docu>
</procedure>
<procedure name="Fit_Multiple_Contours">
<interface>
<io>
<par name="borde_entrada" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="borde_salida" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Number" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Ajusta una linea sobre un conjunto de contornos conectados. Une todos</c>
<c>* los puntos de entrada en un unico contorno artificial y ajusta una</c>
<c>* linea mediante regresion robusta.</c>
<c>*</c>
<c>* ENTRADAS (icono):</c>
<c>* -borde_entrada : conjunto de contornos a unificar y ajustar</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* -Number        : numero de objetos contenidos en borde_entrada</c>
<c>*</c>
<c>* SALIDAS (icono):</c>
<c>* -borde_salida  : linea ajustada como contorno XLD</c>
<c>********************************************************************************</c>
<c></c>
<l>AllRows:=[]</l>
<l>AllCols:=[]</l>
<c></c>
<l>if (0)</l>
<l>    * throw (['Prueba Fit_Multiple_Contours'])</l>
<l>    stop()</l>
<l>endif</l>
<c>    </c>
<l>for Index := 1 to Number by 1</l>
<c></c>
<c>    * Extrer puntos de contorno individual</c>
<l>    select_obj (borde_entrada, ObjectSelected, Index)</l>
<l>    get_contour_xld (ObjectSelected, RowFor, ColFor)</l>
<c>    </c>
<c>    * Unir todos los puntos</c>
<l>    tuple_concat (AllRows, RowFor, AllRows)</l>
<l>    tuple_concat (AllCols, ColFor, AllCols)</l>
<l>endfor</l>
<c></c>
<c>* Generar un solo contorno artificial con todos los puntos</c>
<l>gen_contour_polygon_xld (ContourAll, AllRows, AllCols)    </l>
<c></c>
<c>* Ajustar una linea a los puntos combinados</c>
<l>fit_line_contour_xld (ContourAll, 'tukey', -1, 0, 5, 2, RowBeginIzq, ColBeginIzq, RowEndIzq, ColEndIzq, Nr, Nc, Dist)    </l>
<c></c>
<c>* Crear contorno XLD desde los puntos extremos</c>
<l>gen_contour_polygon_xld (borde_salida, [RowBeginIzq,RowEndIzq], [ColBeginIzq,ColEndIzq])</l>
<l>return ()</l>
</body>
<docu id="Fit_Multiple_Contours">
<parameters>
<parameter id="Number"/>
<parameter id="borde_entrada"/>
<parameter id="borde_salida"/>
</parameters>
</docu>
</procedure>
<procedure name="Load_From_CSV">
<interface>
<ic>
<par name="Path" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Diccionario" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Carga los valores nominales de produccion desde un archivo de configuracion externo.</c>
<c>* En caso de error de lectura o de archivo inexistente, devuelve un codigo de error.</c>
<c>* En la version 2, se eliminan variables y se pone el foco en las variables</c>
<c>* propias de la produccion.</c>
<c>*</c>
<c>* ENTRADAS (control):</c>
<c>* (ninguna)</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* -Diccionario       : diccionario con las variables importadas de un CSV</c>
<c>* -Codigo_Error      : 1 = error general fichero</c>
<c>*                      2 = fichero no encontrado </c>
<c>*                      3 = caracter invalido </c>
<c>********************************************************************************</c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<l>create_dict (Diccionario)</l>
<c></c>
<l>try</l>
<c>    </c>
<c>    * Comprobar si existe el archivo</c>
<l>    file_exists (Path, FileExists)</l>
<c></c>
<l>    if (FileExists == 1)</l>
<c></c>
<c>        * Abrir archivo para lectura</c>
<l>        open_file (Path, 'input', FileHandle)</l>
<c></c>
<c>        * Leer linea a linea hasta final del archivo</c>
<l>        while (true)</l>
<l>            fread_line (FileHandle, OutLine, IsEOF)    </l>
<c></c>
<c>            * Eliminar espacios, tabulaciones, saltos de linea y cambiar comas por puntos</c>
<l>            tuple_str_replace(OutLine, ' ', '', OutLine)</l>
<l>            tuple_str_replace(OutLine, '\t', '', OutLine)  </l>
<l>            tuple_str_replace(OutLine, '\n', '', OutLine)            </l>
<l>            tuple_str_replace(OutLine, ',', '.', OutLine)            </l>
<c>            </c>
<c>            * Extraer primer caracter para detectar comentarios y saltos de linea</c>
<l>            if (not IsEOF)</l>
<l>                tuple_str_first_n (OutLine, 0, Substring)                </l>
<l>            endif</l>
<c>            </c>
<c>            * Procesar linea si no esta vacia</c>
<l>            if (OutLine != '')</l>
<c>                </c>
<c>                * Ignorar comentarios o saltos de linea</c>
<l>                if (Substring != '*' and Substring != '\n') </l>
<c>                    </c>
<c>                    * Separar clave y valores</c>
<l>                    tuple_split (OutLine, ';', V)   </l>
<l>                    tuple_length (V, Length)                    </l>
<l>                    Key:=V[0]                    </l>
<l>                    Values:= V[1:Length - 1]</l>
<c>                                       </c>
<c>                    * Convertir a valores numericos</c>
<l>                    for Index := 0 to |Values| - 1 by 1      </l>
<c>                        </c>
<l>                        tuple_select(Values, Index, Valor)                        </l>
<l>                        tuple_is_number (Valor,IsNumber)  </l>
<c>                                         </c>
<c>                        * Filtrado de caracteres y conversion de tipo</c>
<l>                        if(IsNumber)</l>
<l>                            tuple_number (Valor, Valor)</l>
<l>                            tuple_replace (Values, Index, Valor, Values)      </l>
<l>                        else</l>
<c>                            * Caracter invalido</c>
<l>                            Codigo:=3</l>
<l>                            return ()</l>
<l>                        endif                    </l>
<l>                    endfor</l>
<c>           </c>
<c>                    * Almacenar en diccionarios              </c>
<l>                    set_dict_tuple (Diccionario, Key, Values)</l>
<l>                endif</l>
<l>            else</l>
<c>                * Fin de lectura</c>
<l>                break</l>
<l>            endif</l>
<l>        endwhile</l>
<c></c>
<c>        * Cerrar archivo</c>
<l>        close_file (FileHandle)</l>
<l>    else        </l>
<c>        * Fichero no encontrado</c>
<l>        Codigo_Error := 2</l>
<l>        return ()</l>
<l>    endif</l>
<c></c>
<l>catch (Exception)</l>
<c>    </c>
<c>    * Error general fichero</c>
<l>    Codigo_Error := 1</l>
<l>    return ()</l>
<l>endtry</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="Load_From_CSV">
<parameters>
<parameter id="Codigo_Error"/>
<parameter id="Diccionario"/>
<parameter id="Path"/>
</parameters>
</docu>
</procedure>
<procedure name="Variables_Produccion">
<interface>
<ic>
<par name="Io_Cargar_Fichero" base_type="ctrl" dimension="0"/>
<par name="Io_Fichero_Cargado" base_type="ctrl" dimension="0"/>
<par name="Io_ID_Produccion" base_type="ctrl" dimension="0"/>
<par name="Path" base_type="ctrl" dimension="0"/>
<par name="offline" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Dict_Var_Prod" base_type="ctrl" dimension="0"/>
<par name="ID_Produccion" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* DESCRIPCION:</c>
<c>* Secuencia de carga de valores de produccion desde un CSV</c>
<c>* </c>
<c>* ENTRADAS (control):</c>
<c>* -Io_Cargar_Fichero  : canal que indica si hay que cargar ficheros</c>
<c>* -Io_Fichero_Cargado : canal para comunicar que se ha cargado el fichero</c>
<c>* -Path               : ruta del archivo CSV</c>
<c>* -offline            : flag para ciclos offline</c>
<c>*</c>
<c>* SALIDAS (control):</c>
<c>* -Dict_Var_Prod     : diccionario donde se guardan los valores</c>
<c>* -ID_Produccion     : ID del fichero cargado</c>
<c>* -Codigo_Error      : 203 = error general carga variables de produccion</c>
<c>*                      204 = archivo de variables de produccion no encontrado</c>
<c>*                      205 = error durante la extraccion de variables de produccion</c>
<c>*******************************************************************************</c>
<c></c>
<c>* Inicializar resultado de ejecucion de procedimiento</c>
<l>Codigo_Error := 0</l>
<l>Cargar_Fichero:=1</l>
<c></c>
<l>while (Cargar_Fichero==1)                                                                                                                       </l>
<c></c>
<c>    * Instaciar diccionario con variables de produccion 1</c>
<l>    Load_From_CSV (Path, Dict_Var_Prod, Codigo_Error)</l>
<c>        </c>
<c>    * Convertir errores propios de Load_From_CSV a Load_Prod_Params </c>
<l>    switch (Codigo_Error)</l>
<l>    case 1:</l>
<c>        * Error general carga variables de produccion</c>
<l>        Codigo_Error:=203</l>
<l>        break        </l>
<l>    case 2:</l>
<c>        * Archivo de variables de produccion no encontrado</c>
<l>        Codigo_Error:=204</l>
<l>        break</l>
<l>    case 3:</l>
<c>        * Error durante la extraccion de variables de produccion</c>
<l>        Codigo_Error:=205</l>
<l>        break</l>
<l>    endswitch</l>
<c>    </c>
<l>    if (Codigo_Error == 0)</l>
<c>    </c>
<c>        * Obtener el ID del fichero produccion 1</c>
<l>        get_dict_tuple (Dict_Var_Prod, 'ID', ID_Produccion)</l>
<c>        </c>
<c>        * Secuencia con PLC</c>
<l>        if (offline==0)  </l>
<c>            </c>
<c>            * ID_Produccion</c>
<l>            write_io_channel (Io_ID_Produccion, ID_Produccion, Status)          </l>
<c>                        </c>
<c>            * Enviar respuesta al PLC indicando que se ha realizado la carga</c>
<l>            write_io_channel (Io_Fichero_Cargado, 'true', Status)</l>
<c>            </c>
<c>            * Consultar si se ha quitado la peticion de carga                        </c>
<l>            wait_seconds (1)                        </l>
<l>            read_io_channel (Io_Cargar_Fichero, Cargar_Fichero, Status)</l>
<l>        else</l>
<c>            * Se anula la carga en los siguientes ciclos</c>
<l>            Cargar_Fichero:=0</l>
<l>        endif</l>
<l>    endif</l>
<l>endwhile</l>
<c></c>
<c>* Finalizar respuesta al PLC</c>
<l>if (offline==0)                        </l>
<l>    write_io_channel (Io_Fichero_Cargado, 'false', Status)               </l>
<l>endif     </l>
<c></c>
<l>return ()</l>
</body>
<docu id="Variables_Produccion">
<parameters>
<parameter id="Codigo_Error"/>
<parameter id="Dict_Var_Prod"/>
<parameter id="ID_Produccion"/>
<parameter id="Io_Cargar_Fichero"/>
<parameter id="Io_Fichero_Cargado"/>
<parameter id="Io_ID_Produccion"/>
<parameter id="Path"/>
<parameter id="offline"/>
</parameters>
</docu>
</procedure>
<procedure name="Init_Variables_Globales">
<interface>
<oc>
<par name="Version" base_type="ctrl" dimension="0"/>
<par name="Celda" base_type="ctrl" dimension="0"/>
<par name="offline" base_type="ctrl" dimension="0"/>
<par name="reset_comunicacion" base_type="ctrl" dimension="0"/>
<par name="Umbral_Esp_Medio" base_type="ctrl" dimension="0"/>
<par name="Tol_Esq_Rotas" base_type="ctrl" dimension="0"/>
<par name="xTolerance" base_type="ctrl" dimension="0"/>
<par name="yTolerance" base_type="ctrl" dimension="0"/>
<par name="Area_Min_Error" base_type="ctrl" dimension="0"/>
<par name="Margen_Esp" base_type="ctrl" dimension="0"/>
<par name="Save_Image" base_type="ctrl" dimension="0"/>
<par name="ciclos_debug" base_type="ctrl" dimension="0"/>
<par name="debug_dir" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***** ### VISUALIZACION CELDA ### *****</c>
<l>Version := '1.0'</l>
<l>Celda:='CAFERSA'</l>
<l>reset_comunicacion := 0</l>
<c></c>
<c>***** ### PARAMETROS ### *****</c>
<c>** Control Area **</c>
<c></c>
<c>* Umbral espesor medio dentro de limite</c>
<l>Umbral_Esp_Medio:=50</l>
<c></c>
<c>* Numero de esquinas rotas permitidas por debajo de la tolerancia</c>
<l>* Tol_Esq_Rotas:=4</l>
<l>Tol_Esq_Rotas:=1</l>
<c></c>
<c>* Tolerancia de esquinas rotas: 10mm,10mm</c>
<l>xTolerance:=100</l>
<l>yTolerance:=100</l>
<l>* xTolerance:=10</l>
<l>* yTolerance:=10</l>
<c></c>
<c>* Area minima en pixeles para que cuente como error esquina</c>
<l>* Area_Min_Error:=200 </l>
<l>Area_Min_Error:=3000 </l>
<c></c>
<c>** Control Espesor</c>
<c></c>
<c>* Parte del borde que se quita donde no se mide el espesor</c>
<l>Margen_Esp:=20</l>
<c></c>
<c>***** ### DEBUG VARIABLES ### *****</c>
<c></c>
<c>* Activar guardado de imagenes</c>
<l>Save_Image:=1</l>
<c></c>
<c>* Variables usadas para usar imagenes offline de un directorio</c>
<l>ciclos_debug:=0 </l>
<l>debug_dir:=1</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Init_Variables_Globales">
<parameters>
<parameter id="Area_Min_Error"/>
<parameter id="Celda"/>
<parameter id="Margen_Esp"/>
<parameter id="Save_Image"/>
<parameter id="Tol_Esq_Rotas"/>
<parameter id="Umbral_Esp_Medio"/>
<parameter id="Version"/>
<parameter id="ciclos_debug"/>
<parameter id="debug_dir"/>
<parameter id="offline"/>
<parameter id="reset_comunicacion"/>
<parameter id="xTolerance"/>
<parameter id="yTolerance"/>
</parameters>
</docu>
</procedure>
<procedure name="Init_Variables_Generales">
<interface>
<oc>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
<par name="Vision_Realizada" base_type="ctrl" dimension="0"/>
<par name="Largo_Medido" base_type="ctrl" dimension="0"/>
<par name="Ancho_Medido" base_type="ctrl" dimension="0"/>
<par name="Espesor_Medido" base_type="ctrl" dimension="0"/>
<par name="Tercio_Visible" base_type="ctrl" dimension="0"/>
<par name="Calidad_Tercio_1" base_type="ctrl" dimension="0"/>
<par name="Calidad_Tercio_3" base_type="ctrl" dimension="0"/>
<par name="Fichero_Cargado_1" base_type="ctrl" dimension="0"/>
<par name="Fichero_Cargado_2" base_type="ctrl" dimension="0"/>
<par name="ID_Pizarra_Out" base_type="ctrl" dimension="0"/>
<par name="ciclo" base_type="ctrl" dimension="0"/>
<par name="max_ciclo" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Inicializar variables generales</c>
<c></c>
<c>***** ### SALIDAS ### *****</c>
<l>Codigo_Error:=0</l>
<l>Vision_Realizada:=0</l>
<l>Largo_Medido:=0</l>
<l>Ancho_Medido:=0</l>
<l>Espesor_Medido:=0</l>
<l>Tercio_Visible:=0</l>
<l>Calidad_Tercio_1:=0</l>
<l>Calidad_Tercio_3:=0</l>
<l>Fichero_Cargado_1:=0</l>
<l>Fichero_Cargado_2:=0</l>
<l>ID_Pizarra_Out:=0</l>
<c>    </c>
<c>***** ### VARIABLES INTERNAS ### *****    </c>
<l>ciclo:=0</l>
<l>max_ciclo := 1000000</l>
<l>return ()</l>
</body>
<docu id="Init_Variables_Generales">
<parameters>
<parameter id="Ancho_Medido"/>
<parameter id="Calidad_Tercio_1"/>
<parameter id="Calidad_Tercio_3"/>
<parameter id="Codigo_Error"/>
<parameter id="Espesor_Medido"/>
<parameter id="Fichero_Cargado_1"/>
<parameter id="Fichero_Cargado_2"/>
<parameter id="ID_Pizarra_Out"/>
<parameter id="Largo_Medido"/>
<parameter id="Tercio_Visible"/>
<parameter id="Vision_Realizada"/>
<parameter id="ciclo"/>
<parameter id="max_ciclo"/>
</parameters>
</docu>
</procedure>
<procedure name="Visu_Main">
<interface>
<io>
<par name="ZRed" base_type="iconic" dimension="0"/>
<par name="OriginalRegion" base_type="iconic" dimension="0"/>
<par name="Region_Sup" base_type="iconic" dimension="0"/>
<par name="Region_Inter" base_type="iconic" dimension="0"/>
<par name="Region_Inf" base_type="iconic" dimension="0"/>
<par name="Region_Esp_Inf" base_type="iconic" dimension="0"/>
<par name="Region_Esp_Sup" base_type="iconic" dimension="0"/>
<par name="AreaFaults" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Calidad_Tercio_1" base_type="ctrl" dimension="0"/>
<par name="Calidad_Tercio_3" base_type="ctrl" dimension="0"/>
<par name="Tercio_Visible" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>dev_set_window (WindowHandle)</l>
<c></c>
<c>* Imagen principal</c>
<l>dev_display (ZRed)                    </l>
<c></c>
<c>* Destacar borde visible</c>
<l>intersection (Region_Sup, OriginalRegion, Zona1)</l>
<l>gen_contour_region_xld (Zona1, Zona1_c, 'border')</l>
<c></c>
<l>intersection (Region_Inter, OriginalRegion, Zona2)</l>
<l>gen_contour_region_xld (Zona2, Zona2_c, 'border')</l>
<c></c>
<l>intersection (Region_Inf, OriginalRegion, Zona3)</l>
<l>gen_contour_region_xld (Zona3, Zona3_c, 'border')</l>
<c></c>
<l>dev_set_line_width (3)</l>
<l>Color_Zona2:='blue'</l>
<l>if (Tercio_Visible==1)                         </l>
<c></c>
<c>    * Bordes de zona</c>
<l>    dev_set_color ('blue')                        </l>
<l>    dev_display (Zona2_c)  </l>
<l>    dev_display (Zona3_c)  </l>
<c>    </c>
<l>    if (Calidad_Tercio_1==1)</l>
<l>        Color_Zona1:='green'</l>
<l>    else</l>
<l>        Color_Zona1:='magenta'</l>
<l>    endif</l>
<l>    Color_Zona3:='blue'  </l>
<c>    </c>
<l>    dev_set_color (Color_Zona1)  </l>
<l>    dev_display (Zona1_c)   </l>
<l>elseif (Tercio_Visible==3)      </l>
<c></c>
<c>    * Bordes de zona</c>
<l>    dev_set_color ('blue')                        </l>
<l>    dev_display (Zona2_c)  </l>
<l>    dev_display (Zona1_c)        </l>
<c>    </c>
<l>    Color_Zona1:='blue'</l>
<l>    if (Calidad_Tercio_3==1)</l>
<l>        Color_Zona3:='green'</l>
<l>    else</l>
<l>        Color_Zona3:='magenta'</l>
<l>    endif</l>
<c>    </c>
<l>    dev_set_color (Color_Zona3)                        </l>
<l>    dev_display (Zona3_c)                        </l>
<l>else </l>
<c></c>
<c>    * Bordes de zona</c>
<l>    dev_set_color ('red')                        </l>
<l>    dev_display (Zona2_c)  </l>
<l>    dev_display (Zona1_c)     </l>
<l>    dev_display (Zona3_c)    </l>
<c>    </c>
<l>    Color_Zona1:='red'</l>
<l>    Color_Zona2:='red'</l>
<l>    Color_Zona3:='red'</l>
<l>endif                                                             </l>
<c></c>
<c>* Mostrar areas faltantes significativas</c>
<l>dev_set_color ('white')</l>
<l>dev_display (AreaFaults)  </l>
<c></c>
<c>* Mostrar espesor fuera de rango</c>
<l>dev_set_color ('red')</l>
<l>dev_display (Region_Esp_Inf)</l>
<l>dev_display (Region_Esp_Sup)</l>
<c></c>
<c>** Etiquetas calidad zona **</c>
<l>set_display_font (WindowHandle, 14, 'mono', 'false', 'false')</l>
<c></c>
<c>* Zona 1</c>
<l>area_center (Region_Sup, Area, Row, Column)</l>
<l>dev_disp_text ('Zona 1', 'image', Row, Column, Color_Zona1, [], [])</l>
<c></c>
<l>if (Calidad_Tercio_1==-1)</l>
<l>    dev_disp_text ('Descarte', 'image', Row+100, Column, Color_Zona1, [], [])                                              </l>
<l>else</l>
<l>    dev_disp_text ('Calidad : ' + Calidad_Tercio_1 + 'º', 'image', Row+100, Column, Color_Zona1, [], [])                      </l>
<l>endif</l>
<c></c>
<c>* Zona 2</c>
<l>area_center (Region_Inter, Area, Row, Column)</l>
<l>dev_disp_text ('Zona 2', 'image', Row, Column, Color_Zona2, [], [])</l>
<c></c>
<c>* Zona 3</c>
<l>area_center (Region_Inf, Area, Row, Column)</l>
<l>dev_disp_text ('Zona 3', 'image', Row, Column, Color_Zona3, [], [])                  </l>
<c></c>
<l>if (Calidad_Tercio_3==-1)</l>
<l>    dev_disp_text ('Descarte', 'image', Row+100, Column, Color_Zona3, [], [])                                              </l>
<l>else</l>
<l>    dev_disp_text ('Calidad : ' + Calidad_Tercio_3 + 'º', 'image', Row+100, Column, Color_Zona3, [], [])                      </l>
<l>endif                    </l>
<l>return ()</l>
</body>
<docu id="Visu_Main">
<parameters>
<parameter id="AreaFaults"/>
<parameter id="Calidad_Tercio_1"/>
<parameter id="Calidad_Tercio_3"/>
<parameter id="OriginalRegion"/>
<parameter id="Region_Esp_Inf"/>
<parameter id="Region_Esp_Sup"/>
<parameter id="Region_Inf"/>
<parameter id="Region_Inter"/>
<parameter id="Region_Sup"/>
<parameter id="Tercio_Visible"/>
<parameter id="WindowHandle"/>
<parameter id="ZRed"/>
</parameters>
</docu>
</procedure>
<procedure name="Visu_Main_2">
<interface>
<io>
<par name="Rectangle_Norm" base_type="iconic" dimension="0"/>
<par name="Rectangle_Norm_Esq" base_type="iconic" dimension="0"/>
<par name="Bordes_Norm" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandle1" base_type="ctrl" dimension="0"/>
<par name="WindowHandle2" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
<par name="ID_Pizarra_Out" base_type="ctrl" dimension="0"/>
<par name="Dict_Var_Prod" base_type="ctrl" dimension="0"/>
<par name="Espesor_Nominal" base_type="ctrl" dimension="0"/>
<par name="Largo_Medio" base_type="ctrl" dimension="0"/>
<par name="Ancho_Medio" base_type="ctrl" dimension="0"/>
<par name="Espesor_Medio" base_type="ctrl" dimension="0"/>
<par name="Per_Esp_Medio" base_type="ctrl" dimension="0"/>
<par name="Espesor_Minimo" base_type="ctrl" dimension="0"/>
<par name="Esquinas_Rotas" base_type="ctrl" dimension="0"/>
<par name="Corner_Rows" base_type="ctrl" dimension="0"/>
<par name="Corner_Cols" base_type="ctrl" dimension="0"/>
<par name="xTolerance" base_type="ctrl" dimension="0"/>
<par name="xResolution" base_type="ctrl" dimension="0"/>
<par name="yTolerance" base_type="ctrl" dimension="0"/>
<par name="yResolution" base_type="ctrl" dimension="0"/>
<par name="Dimensiones" base_type="ctrl" dimension="0"/>
<par name="Umbral_Esp_Medio" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Largo_Nominal" base_type="ctrl" dimension="0"/>
<par name="Ancho_Nominal" base_type="ctrl" dimension="0"/>
<par name="Phi" base_type="ctrl" dimension="0"/>
<par name="Index" base_type="ctrl" dimension="0"/>
<par name="Per_Esp_MedioOut" base_type="ctrl" dimension="0"/>
<par name="Espesor_MinimoOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Espesor_MinimoOut := Espesor_Minimo</l>
<l>Per_Esp_MedioOut := Per_Esp_Medio</l>
<l>                    dev_set_window (WindowHandle2)</l>
<c>                    </c>
<c>                    * ID de pizarra</c>
<l>                    dev_disp_text ('ID Pizarra:'+ID_Pizarra_Out, 'window', 'top', 'center', 'black', [], [])</l>
<c>                                   </c>
<c>                    * Valores nominales</c>
<l>                    get_dict_tuple (Dict_Var_Prod, 'Largo', Largo_Nominal)</l>
<l>                    get_dict_tuple (Dict_Var_Prod, 'Ancho', Ancho_Nominal)</l>
<l>                    set_display_font (WindowHandle2, 16, 'mono', 'true', 'false')</l>
<l>                    dev_disp_text ('Valores Nominales', 'window', 100, 'left', 'black', [], [])</l>
<l>                    set_display_font (WindowHandle2, 14, 'mono', 'true', 'false')                   </l>
<l>                    dev_disp_text ('Largo:'+Largo_Nominal, 'window', 130, 'left', 'black', [], [])</l>
<l>                    dev_disp_text ('Ancho:'+Ancho_Nominal, 'window', 150, 'left', 'black', [], [])</l>
<l>                    dev_disp_text ('Espesor:'+Espesor_Nominal, 'window', 170, 'left', 'black', [], [])</l>
<c>                    </c>
<c>                    * Valores medidos</c>
<l>                    set_display_font (WindowHandle2, 16, 'mono', 'true', 'false')</l>
<l>                    dev_disp_text ('Valores Medidos', 'window', 100, 'right', 'black', [], [])</l>
<l>                    set_display_font (WindowHandle2, 14, 'mono', 'true', 'false')                   </l>
<l>                    dev_disp_text ('Largo medio:'+Largo_Medio, 'window', 130, 'right', 'black', [], [])</l>
<l>                    dev_disp_text ('Ancho medio:'+Ancho_Medio, 'window', 150, 'right', 'black', [], [])</l>
<l>                    dev_disp_text ('Espesor medio:'+Espesor_Medio, 'window', 170, 'right', 'black', [], [])                    </l>
<c>                    </c>
<c>                    * Codigo error</c>
<l>                    set_display_font (WindowHandle2, 16, 'mono', 'true', 'false')</l>
<l>                    if (Codigo_Error==0)</l>
<l>                        dev_disp_text ('Pizarra OK', 'window', 'center', 'center', 'green', [], [])                                           </l>
<l>                    else</l>
<l>                        dev_disp_text ('Codigo Error:'+Codigo_Error, 'window', 'center', 'center', 'red', [], [])                                            </l>
<l>                    endif</l>
<c>                    </c>
<c>                    * Mensaje de error</c>
<l>                    switch (Codigo_Error)</l>
<l>                    case 100:  </l>
<c>                                                </c>
<c>                        * Mostrar tolerancias</c>
<l>                        dev_set_window (WindowHandle1)</l>
<l>                        dev_set_line_width (1)</l>
<l>                        dev_set_color ('white')</l>
<l>                        gen_contour_region_xld (Rectangle_Norm_Esq, RegionContours, 'border')</l>
<l>                        dev_display (RegionContours)</l>
<c>                        </c>
<c>                        * Mensaje de error                        </c>
<l>                        dev_set_window (WindowHandle2)</l>
<l>                        dev_disp_text ('Defecto esquina fuera de tolerancia', 'window', 300, 'center', 'red', [], [])    </l>
<c>                        </c>
<l>                        break</l>
<c>                        </c>
<l>                    case 101:</l>
<c>                        </c>
<l>                        dev_set_window (WindowHandle1)</l>
<l>                        dev_set_color ('red')</l>
<l>                        dev_set_line_width (1)</l>
<l>                        region_features (Rectangle_Norm, 'phi', Phi)</l>
<c>                        * Mostrar esquinas afectadas</c>
<l>                        for Index := 0 to 3 by 1                    </l>
<l>                            if (Esquinas_Rotas[Index])</l>
<l>                                 gen_rectangle2_contour_xld (Contour, Corner_Rows[Index], Corner_Cols[Index], Phi, xTolerance/xResolution, yTolerance/yResolution)                    </l>
<l>                                 dev_display(Contour)</l>
<l>                            endif                                                  </l>
<l>                        endfor                    </l>
<c>                        </c>
<c>                        * Mensaje de error     </c>
<l>                        dev_set_window (WindowHandle2)</l>
<l>                        dev_disp_text ('Varias esquinas con defecto dentro de tolerancia', 'window',300, 'center', 'red', [], [])   </l>
<c>                        </c>
<l>                        break</l>
<c>                        </c>
<l>                    case 110:</l>
<c>                                                </c>
<c>                        * Mostrar dimensiones de bordes normalizados</c>
<l>                        dev_set_window (WindowHandle1)</l>
<l>                        dev_set_line_width (1)                   </l>
<l>                        dev_set_color ('red')</l>
<l>                        dev_display (Bordes_Norm)</l>
<c>                        </c>
<c>                        * Mostrar acotaciones borde</c>
<l>                        for Index := 0 to 3 by 1</l>
<l>                            select_obj (Bordes_Norm, borde, Index+1)</l>
<l>                            acotacion (borde, WindowHandle1, 100, Index+1, Dimensiones[Index])</l>
<l>                        endfor</l>
<c>                        </c>
<c>                        * Mensaje de error</c>
<l>                        dev_set_window (WindowHandle2)</l>
<l>                        dev_disp_text ('No cumple largo', 'window',300, 'center', 'red', [], [])</l>
<c>                            </c>
<l>                        break</l>
<c>                    </c>
<l>                    case 111:</l>
<c>                        </c>
<c>                         * Mostrar dimensiones de bordes normalizados</c>
<l>                        dev_set_window (WindowHandle1)</l>
<l>                        dev_set_line_width (1)                        </l>
<l>                        dev_display (Bordes_Norm)</l>
<c>                        </c>
<c>                        * Mostrar acotaciones borde</c>
<l>                        for Index := 0 to 3 by 1</l>
<l>                            select_obj (Bordes_Norm, borde, Index+1)</l>
<l>                            acotacion (borde, WindowHandle1, 100, Index+1, Dimensiones[Index])</l>
<l>                        endfor</l>
<c>                        </c>
<c>                        * Mensaje de error</c>
<l>                        dev_set_window (WindowHandle2)</l>
<l>                        dev_disp_text ('No cumple ancho', 'window',300, 'center', 'red', [], [])</l>
<c>                                                    </c>
<l>                        break</l>
<c>                    </c>
<l>                    case 112:                </l>
<c>                                                   </c>
<c>                        * Mensaje de error</c>
<l>                        dev_set_window (WindowHandle2)</l>
<l>                        dev_disp_text ('No cumple espesor medio', 'window',300, 'center', 'red', [], [])</l>
<c></c>
<c>                        ** Informacion adicional**</c>
<l>                        tuple_string (Per_Esp_MedioOut, '.2f', Per_Esp_MedioOut)</l>
<l>                        dev_disp_text ('Porcentaje en rango: '+ Per_Esp_MedioOut + '/' + Umbral_Esp_Medio, 'window', 330, 'center', 'red', [], [])</l>
<c>                                                                        </c>
<l>                        break                            </l>
<c>                                        </c>
<l>                    case 113:                                       </l>
<c>                        </c>
<c>                        * Mensaje de error</c>
<l>                        dev_set_window (WindowHandle2)</l>
<l>                        dev_disp_text ('No cumple espesor mínimo', 'window',300, 'center', 'red', [], [])</l>
<c></c>
<c>                        ** Informacion adicional**</c>
<l>                        tuple_string (Espesor_MinimoOut, '.2f', Espesor_MinimoOut)</l>
<l>                        dev_disp_text ('Espesor minimo medido: '+ Espesor_MinimoOut, 'window', 350, 'center', 'red', [], [])</l>
<l>                        dev_disp_text ('Umbral espesor minimo :2', 'window',380 , 'center' ,'red', [], [])                                </l>
<c>                        </c>
<l>                        break                                                                 </l>
<l>                    endswitch                                                          </l>
<l>return ()</l>
</body>
<docu id="Visu_Main_2">
<parameters>
<parameter id="Ancho_Medio"/>
<parameter id="Ancho_Nominal"/>
<parameter id="Bordes_Norm"/>
<parameter id="Codigo_Error"/>
<parameter id="Corner_Cols"/>
<parameter id="Corner_Rows"/>
<parameter id="Dict_Var_Prod"/>
<parameter id="Dimensiones"/>
<parameter id="Espesor_Medio"/>
<parameter id="Espesor_Minimo"/>
<parameter id="Espesor_MinimoOut"/>
<parameter id="Espesor_Nominal"/>
<parameter id="Esquinas_Rotas"/>
<parameter id="ID_Pizarra_Out"/>
<parameter id="Index"/>
<parameter id="Largo_Medio"/>
<parameter id="Largo_Nominal"/>
<parameter id="Per_Esp_Medio"/>
<parameter id="Per_Esp_MedioOut"/>
<parameter id="Phi"/>
<parameter id="Rectangle_Norm"/>
<parameter id="Rectangle_Norm_Esq"/>
<parameter id="Umbral_Esp_Medio"/>
<parameter id="WindowHandle1"/>
<parameter id="WindowHandle2"/>
<parameter id="xResolution"/>
<parameter id="xTolerance"/>
<parameter id="yResolution"/>
<parameter id="yTolerance"/>
</parameters>
</docu>
</procedure>
<procedure name="Visu_Error_Sistema">
<interface>
<ic>
<par name="WindowHandle1" base_type="ctrl" dimension="0"/>
<par name="Codigo_Error" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>                    dev_set_window (WindowHandle1)</l>
<l>                    set_display_font (WindowHandle1, 20, 'mono', 'true', 'false')</l>
<l>                    switch (Codigo_Error)</l>
<l>                    case 9998:</l>
<l>                        dev_disp_text ('Error lectura canales OPC UA','window','center', 'center', 'red', [], [])</l>
<l>                        break</l>
<c>                        </c>
<l>                    case 9999:    </l>
<c>                    </c>
<l>                        dev_disp_text ('Error de comunicación PC-PLC','window','center', 'center', 'red', [], [])</l>
<l>                        break                        </l>
<l>                    endswitch</l>
<l>return ()</l>
</body>
<docu id="Visu_Error_Sistema">
<parameters>
<parameter id="Codigo_Error"/>
<parameter id="WindowHandle1"/>
</parameters>
</docu>
</procedure>
<procedure name="Background">
<interface>
<ic>
<par name="Io_LiveBit_In" base_type="ctrl" dimension="0"/>
<par name="Io_LiveBit_Out" base_type="ctrl" dimension="0"/>
<par name="offline" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>global tuple SharedDataBack</l>
<c></c>
<l>while (1)</l>
<c></c>
<l>    if (offline==0)</l>
<l>        read_io_channel (Io_LiveBit_In, LiveBit_In, Status)</l>
<l>        write_io_channel (Io_LiveBit_Out, LiveBit_In, Status)</l>
<l>    else</l>
<c>        * Pruebas tiempo ciclo</c>
<l>        LiveBit_In:=1</l>
<l>        LiveBit_In:=0        </l>
<l>        LiveBit_In:=1</l>
<l>        LiveBit_In:=0 </l>
<l>        LiveBit_In:=1</l>
<l>        LiveBit_In:=0 </l>
<l>        LiveBit_In:=1</l>
<l>        LiveBit_In:=0         </l>
<l>        LiveBit_In:=1</l>
<l>        LiveBit_In:=0         </l>
<l>        LiveBit_In:=1</l>
<l>        LiveBit_In:=0        </l>
<l>        LiveBit_In:=1</l>
<l>        LiveBit_In:=0 </l>
<l>        LiveBit_In:=1</l>
<l>        LiveBit_In:=0 </l>
<l>        LiveBit_In:=1</l>
<l>        LiveBit_In:=0         </l>
<l>        LiveBit_In:=1</l>
<l>        LiveBit_In:=0  </l>
<l>        tuple_abs (LiveBit_In, Abs)</l>
<l>        tuple_cos (Abs, Cos)</l>
<l>        tuple_sin (Abs, Sin)</l>
<l>        tuple_tan (Abs, Tan)</l>
<l>    endif</l>
<l>    wait_seconds (0.5)</l>
<l>endwhile</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Background">
<parameters>
<parameter id="Io_LiveBit_In"/>
<parameter id="Io_LiveBit_Out"/>
<parameter id="offline"/>
</parameters>
</docu>
</procedure>
<procedure name="query_detailed_aop_information">
<interface>
<ic>
<par name="Operator" base_type="ctrl" dimension="0"/>
<par name="IconicTypeStep" base_type="ctrl" dimension="0"/>
<par name="IconicType" base_type="ctrl" dimension="0"/>
<par name="ParStep" base_type="ctrl" dimension="0"/>
<par name="ParValue" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Message" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Message := []</l>
<l>for Index := 0 to |ParValue| - 1 by 1</l>
<l>  ParameterValue := ParValue[Index]</l>
<l>  tuple_regexp_match (ParStep[Index], 'parameter:(.+)', ParNumber)</l>
<l>  get_aop_info (Operator, [IconicTypeStep,ParStep[Index]], [IconicType,ParameterValue], 'max_threads', MaxThreads)</l>
<l>  get_aop_info (Operator, [IconicTypeStep,ParStep[Index]], [IconicType,ParameterValue], 'split_level', SplitLevel)</l>
<l>  get_aop_info (Operator, [IconicTypeStep,ParStep[Index]], [IconicType,ParameterValue], 'model', Model)</l>
<l>  Message := [Message,Operator + ', iconic type: ' + IconicType,' Parameter ' + ParNumber + ' = \'' + ParameterValue + '\'']</l>
<l>  Message := [Message,'max_threads = ' + MaxThreads,'split_level = ' + SplitLevel,'model = ' + Model,' ']</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="query_detailed_aop_information">
<parameters>
<parameter id="IconicType"/>
<parameter id="IconicTypeStep"/>
<parameter id="Message"/>
<parameter id="Operator"/>
<parameter id="ParStep"/>
<parameter id="ParValue"/>
</parameters>
</docu>
</procedure>
</hdevelop>
